local USER_CREDENTIALS = {
    username = "akagikay", -- Your dashboard username
    password = "12345t"    -- Your dashboard password
}

-- TIMING CONFIGURATION
local PING_INTERVAL = 120        -- Ping server every 2 minutes
local INVENTORY_INTERVAL = 43200 -- Send inventory every 12 hours (12 * 60 * 60)
local INITIAL_WAIT = 300          -- Wait time upon script load before sending first inventory (allows GUI to load)

-- GITHUB DYNAMIC URL SOURCES
local URLS = {
    RECEPTOR = "https://raw.githubusercontent.com/akagikay/adoptmemanager/refs/heads/main/receptor_url.txt",
    KEEPALIVE = "https://raw.githubusercontent.com/akagikay/adoptmemanager/refs/heads/main/keepalive_url.txt"
}

-- DEBUGGING
local DEBUG_MODE = false         -- Set to true to save raw inventory JSON to file
local DEBUG_FILENAME = "raw_inventory_data_pretty.json"

-- GAME PATHS
local TARGET_MODULE_PATH = "ClientStore"
local BASE_SERVICE_PATH = game:GetService("ReplicatedStorage"):WaitForChild("ClientModules"):WaitForChild("Core")

--================================================================================
-- CORE UTILITIES & HTTP SETUP
--================================================================================

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()

-- Detect Executor HTTP Request Function
local http_request = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
if not http_request then
    warn("Executor does not support HTTP requests. Script cannot run.")
    return
end

-- Helper: Fetch dynamic URL from GitHub text file
local function fetch_dynamic_url(github_url)
    local success, response = pcall(function()
        return game:HttpGet(github_url)
    end)
    
    if success and response then
        -- Remove newlines and whitespace
        return response:gsub("^%s*(.-)%s*$", "%1")
    else
        warn("Failed to fetch dynamic URL from GitHub: " .. github_url)
        return nil
    end
end

--================================================================================
-- JSON PRETTY PRINT UTILITIES (For Debugging)
--================================================================================

local function is_json_array(tbl)
    if type(tbl) ~= "table" then return false end
    local n = 0
    for k, _ in pairs(tbl) do
        n = n + 1
        if type(k) ~= "number" or k < 1 or math.floor(k) ~= k then return false end
    end
    return true
end

local function pretty_json_recursive(val, indent)
    local valType = type(val)
    if valType == "string" then return string.format("%q", val)
    elseif valType == "number" or valType == "boolean" then return tostring(val)
    elseif valType == "nil" then return "null"
    elseif valType == "table" then
        local nextIndent = indent .. "  "
        local items = {}
        if is_json_array(val) then
            for _, v in ipairs(val) do table.insert(items, nextIndent .. pretty_json_recursive(v, nextIndent)) end
            return "[\n" .. table.concat(items, ",\n") .. "\n" .. indent .. "]"
        else
            for k, v in pairs(val) do
                table.insert(items, nextIndent .. string.format("%q", tostring(k)) .. ": " .. pretty_json_recursive(v, nextIndent))
            end
            return "{\n" .. table.concat(items, ",\n") .. "\n" .. indent .. "}"
        end
    end
    return '"unhandled_type"'
end

--================================================================================
-- INVENTORY LOGIC
--================================================================================

local function getModuleFromPath(base, path)
    local current = base
    for segment in path:gmatch("[^.]+") do
        if not current then return nil end
        current = current:FindFirstChild(segment)
    end
    return current
end

local function extractInventory(data)
    if type(data) == "table" and data.store and data.store._state and data.store._state.inventory then
        return data.store._state.inventory
    end
    return nil
end

local function getBucksValue()
    -- Attempts to read the money value from PlayerGui
    local success, amount = pcall(function()
        local gui = LocalPlayer:WaitForChild("PlayerGui", 30)
        local indicator = gui:WaitForChild("BucksIndicatorApp", 10):WaitForChild("CurrencyIndicator", 10)
        local textLabel = indicator:WaitForChild("Container", 10):WaitForChild("Amount", 10)
        
        local cleanText = textLabel.Text:gsub("[^%d%.]", "") -- Remove commas/symbols
        return tonumber(cleanText)
    end)
    
    if success and amount then return amount end
    warn("Could not scrape Bucks value from GUI.")
    return nil
end

local function sendInventory()
    print("[Inventory] Starting process...")
    
    -- 1. Get Dynamic URL
    local serverUrl = fetch_dynamic_url(URLS.RECEPTOR)
    if not serverUrl or serverUrl == "" then return warn("[Inventory] Missing Server URL") end
    
    -- 2. Extract Data
    local moduleScript = getModuleFromPath(BASE_SERVICE_PATH, TARGET_MODULE_PATH)
    if not moduleScript then return warn("[Inventory] ClientStore module not found") end
    
    local success, result = pcall(require, moduleScript)
    if not success then return warn("[Inventory] Failed to require ClientStore") end
    
    local inventory = extractInventory(result)
    if not inventory then return warn("[Inventory] Failed to extract inventory table") end
    
    -- 3. Add Bucks
    local bucks = getBucksValue()
    if bucks then inventory.bucks = bucks end
    
    -- 4. Prepare Payload
    local payload = {
        creds = string.format("%s:%s:%s", USER_CREDENTIALS.username, USER_CREDENTIALS.password, LocalPlayer.Name),
        inv = inventory
    }
    
    -- Debug: Save to file
    if DEBUG_MODE and writefile then
        pcall(writefile, DEBUG_FILENAME, pretty_json_recursive(payload, ""))
        print("[Inventory] Debug file saved.")
    end
    
    -- 5. Send Request
    local reqSuccess, reqResponse = pcall(function()
        return http_request({
            Url = serverUrl .. "/receive-data",
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(payload)
        })
    end)
    
    if reqSuccess and reqResponse.StatusCode == 200 then
        print("[Inventory] Sent successfully.")
    else
        warn("[Inventory] Failed to send. Status: " .. tostring(reqResponse and reqResponse.StatusCode or "Unknown"))
    end
end

--================================================================================
-- KEEPALIVE / PING LOGIC
--================================================================================

local function sendPing()
    local tunnelUrl = fetch_dynamic_url(URLS.KEEPALIVE)
    if not tunnelUrl then return warn("[Ping] Skipped - No Tunnel URL") end
    
    local payload = {
        user = USER_CREDENTIALS.username,
        password = USER_CREDENTIALS.password,
        roblox_username = LocalPlayer.Name
    }
    
    local success, response = pcall(function()
        return http_request({
            Url = tunnelUrl .. "/ping",
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(payload)
        })
    end)
    
    if success and response.StatusCode == 200 then
        print("[Ping] Success (" .. LocalPlayer.Name .. ")")
    else
        warn("[Ping] Failed. Status: " .. tostring(response and response.StatusCode or "Err"))
    end
end

--================================================================================
-- MAIN THREADS
--================================================================================

if not game:IsLoaded() then game.Loaded:Wait() end

-- Thread 1: Keep Alive (Every 2 Minutes)
task.spawn(function()
    print("Keep-Alive Thread Started")
    while true do
        sendPing()
        task.wait(PING_INTERVAL)
    end
end)

-- Thread 2: Inventory Sender (Every 12 Hours)
task.spawn(function()
    print("Inventory Thread Started - Waiting " .. INITIAL_WAIT .. "s for game load...")
    task.wait(INITIAL_WAIT) -- Wait for game/GUI to fully initialize
    
    while true do
        sendInventory()
        print("Next inventory update in 12 hours...")
        task.wait(INVENTORY_INTERVAL)
    end
end)
