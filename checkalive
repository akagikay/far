wait(100)
-- checkalive.lua

local KEEPALIVE_TUNNEL_URL = "https://raw.githubusercontent.com/akagikay/adoptmemanager/refs/heads/main/keepalive_url.txt" -- THIS IS AN EXAMPLE URL

-- The user's credentials for authentication.
local USER_CREDENTIALS = {
    user = "akagikay", -- The main username for the account group
    password = "12345t"   -- The password for the account group
}

-- How often to send a ping, in seconds. (Default: 60 seconds)
local PING_INTERVAL = 120

--[[
================================================================================
  DO NOT EDIT BELOW THIS LINE
================================================================================
--]]

-- Check for http_request function (syn.request for Synapse X, etc.)
local http_request_func = nil
if syn and syn.request then
    http_request_func = syn.request
    print("Using syn.request for HTTP calls.")
elseif request then
    http_request_func = request
    print("Using global 'request' for HTTP calls.")
else
    warn("HTTP request function (syn.request or global request) not found. The script cannot run.")
    return
end

-- Function to fetch the latest tunnel URL
local function get_latest_tunnel_url()
    print("Fetching latest keep-alive tunnel URL...")
    local success, response = pcall(function()
        return http_request_func({
            Url = KEEPALIVE_TUNNEL_URL,
            Method = "GET"
        })
    end)

    if success and response and response.StatusCode == 200 and response.Body then
        local url = response.Body:match("^https?://[%w%-]+%.trycloudflare%.com")
        if url then
            print("Successfully fetched tunnel URL: " .. url)
            return url
        else
            warn("Could not parse a valid tunnel URL from the response body.")
            return nil
        end
    else
        warn("Failed to fetch the keep-alive tunnel URL. Response:")
        if response then
            for k, v in pairs(response) do
                print(string.format("  %s: %s", tostring(k), tostring(v)))
            end
        end
        return nil
    end
end

-- Function to send the keep-alive ping
local function send_ping(tunnel_url)
    if not tunnel_url then
        warn("Cannot send ping: Tunnel URL is missing.")
        return
    end

    -- Get the local player's username
    local localPlayer = game:GetService("Players").LocalPlayer
    if not localPlayer then
        warn("Could not find LocalPlayer. Cannot send ping.")
        return
    end
    local robloxUsername = localPlayer.Name

    local endpoint_url = tunnel_url .. "/ping"

    -- Create the data payload with the new roblox_username field
    local ping_data = {
        user = USER_CREDENTIALS.user,
        password = USER_CREDENTIALS.password,
        roblox_username = robloxUsername
    }

    local payload, json_err = game:GetService("HttpService"):JSONEncode(ping_data)

    if json_err then
        warn("Failed to encode JSON payload: " .. tostring(json_err))
        return
    end

    print("Sending ping for Roblox user '" .. robloxUsername .. "' to: " .. endpoint_url)

    local success, response = pcall(function()
        return http_request_func({
            Url = endpoint_url,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = payload
        })
    end)

    if success and response then
        if response.StatusCode == 200 then
            print("Ping successful! Server responded OK.")
        else
            print(string.format("Ping failed. Server responded with status code %d.", response.StatusCode))
            print("Response Body: " .. tostring(response.Body))
        end
    else
        warn("An error occurred while sending the HTTP request.")
    end
end

-- Main loop
task.spawn(function()
    print("Keep-Alive Script Started.")
    print("-------------------------")
    print("User: " .. USER_CREDENTIALS.user)
    print("Ping Interval: " .. PING_INTERVAL .. " seconds")
    print("-------------------------")

    local current_tunnel_url = nil

    while task.wait(PING_INTERVAL) do
        -- Fetch the URL on the first run or if it was previously nil
        if not current_tunnel_url then
            current_tunnel_url = get_latest_tunnel_url()
        end

        -- If we have a URL, send the ping
        if current_tunnel_url then
            send_ping(current_tunnel_url)
        else
            warn("Skipping ping because the tunnel URL could not be retrieved. Will retry fetching next cycle.")
        end
    end
end)
