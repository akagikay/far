wait(60)
-- Adopt Me Zotti Autofarm by 0_Void (UI-less Version)
getgenv().farmsettings = {
    pet = "", -- Leave blank for auto-select
    babyfarm = true,
    switchpetsongrown = false, -- False for age potions
	prioritizeeggs = false,
}

if getgenv().running then 
    warn("Script already running")
    return 
end
getgenv().running = true

repeat task.wait() until game:IsLoaded()
local t = require(game:GetService("ReplicatedStorage"):WaitForChild("ClientModules").Game.Tutorial.LegacyTutorial)
hookfunction(t.run_avatar_tutorial,function()end)
hookfunction(t.run_housing_tutorial,function()end)
hookfunction(t.run_nursery_tutorial,function()end)

-- Set default settings if not provided
getgenv().farmsettings = getgenv().farmsettings or {
    pet = "Aztec Egg",
    babyfarm = true,
    switchpetsongrown = true,
    prioritizeeggs = false,
}

-- Initialize settings with defaults
getgenv().farmsettings.pet = getgenv().farmsettings.pet or ""
getgenv().farmsettings.babyfarm = getgenv().farmsettings.babyfarm == nil and true or getgenv().farmsettings.babyfarm
getgenv().farmsettings.switchpetsongrown = if getgenv().farmsettings.switchpetsongrown == nil then false else getgenv().farmsettings.switchpetsongrown
getgenv().farmsettings.prioritizeeggs = if getgenv().farmsettings.prioritizeeggs == nil then false else getgenv().farmsettings.prioritizeeggs

-- Wait for game to load
repeat task.wait() until game:IsLoaded()
task.wait(5)
setthreadidentity(2)
-- Services and modules
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local GuiService = game:GetService("GuiService")
local plr = Players.LocalPlayer
local router = require(ReplicatedStorage.ClientModules.Core.RouterClient.RouterClient)
local cd = require(ReplicatedStorage.ClientModules.Core.ClientData)
local petentitymanager = require(ReplicatedStorage.ClientModules.Game.PetEntities.PetEntityManager)
local inventorydb = require(ReplicatedStorage.ClientDB.Inventory.InventoryDB)

local terrainhelper = require(game:GetService("ReplicatedStorage").SharedModules.TerrainHelper)
local Fsys = require(ReplicatedStorage.Fsys)
local liveopstime = Fsys.load("LiveOpsTime")
setthreadidentity(8)
if plr.Character == nil then
	router.get("LegacyTutorialAPI/MarkTutorialCompleted"):FireServer()
	router.get("LegacyTutorialAPI/EquipTutorialEgg"):FireServer()
    repeat 
        local playbutton = game:GetService("Players").LocalPlayer.PlayerGui.NewsApp.EnclosingFrame.MainFrame.Buttons.PlayButton
        firesignal(playbutton.MouseButton1Down)
        firesignal(playbutton.MouseButton1Up)
        firesignal(playbutton.MouseButton1Click)
        task.wait(1)
		if game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Visible then
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Info.Response:GetChildren()[8].MouseButton1Down)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Info.Response:GetChildren()[8].MouseButton1Up)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Info.Response:GetChildren()[8].MouseButton1Click)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Buttons.ButtonTemplate.MouseButton1Down)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Buttons.ButtonTemplate.MouseButton1Up)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Buttons.ButtonTemplate.MouseButton1Click)
        else
			firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.SpawnChooserDialog.UpperCardContainer.ChoicesContent.Choices.Home.Button.MouseButton1Down)
			firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.SpawnChooserDialog.UpperCardContainer.ChoicesContent.Choices.Home.Button.MouseButton1Up)
			firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.SpawnChooserDialog.UpperCardContainer.ChoicesContent.Choices.Home.Button.MouseButton1Click)
		end
    until not (plr.Character == nil)
end

-- New function to buy Aztec Eggs
local function buyAztecEggs()
    local eggsBought = 0
    local maxEggs = 50
    
    warn("Checking money and attempting to buy Aztec Eggs...")
    
    for i = 1, maxEggs do
        local success, result = pcall(function()
            local args = {"pets", "aztec_egg_2025_aztec_egg", {}}
            return game:GetService("ReplicatedStorage").API:FindFirstChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
        end)
        
        if success then
            if result then
                eggsBought = eggsBought + 1
                warn("Successfully bought Aztec Egg #" .. eggsBought)
                task.wait(0.5) -- Wait for inventory to update
                
                local hasNewEgg = false
                for petId, petData in pairs(cd.get("inventory").pets) do
                    if inventorydb.pets[petData.kind] and inventorydb.pets[petData.kind].name == "Aztec Egg" then
                        hasNewEgg = true
                        break
                    end
                end
                
                if hasNewEgg then
                    warn("Confirmed egg purchase in inventory.")
                    return eggsBought
                end
            else
                warn("Failed to buy egg, likely insufficient funds.")
                break
            end
        else
            warn("Error while trying to buy egg: " .. tostring(result))
            break
        end
        
        if i >= 3 and eggsBought == 0 then
            warn("Stopping purchase attempt after 3 failures.")
            break
        end
    end
    
    return eggsBought
end

-- Define minigame helper functions based on your script's structure
local function loadInteriorForJoin(name)
    setthreadidentity(2) 
    local Fsys = game:GetService("ReplicatedStorage"):WaitForChild("Fsys", 5)
    if not Fsys then warn("[Hauntlet] Fsys module not found.") return end
    
    local success, result = pcall(function()
        local FsysModule = require(Fsys)
        local load = FsysModule.load
        local interiors = load("InteriorsM")
        interiors.enter(name, "", {})
        return true
    end)
    if not success then
        warn(string.format("[Hauntlet] CRITICAL FAILURE: Interior load failed! Error: %s", tostring(result)))
    end
    setthreadidentity(8) 
end

local function tryJoinHauntlet()
    local oldPos = plr.Character:WaitForChild("HumanoidRootPart").CFrame
    warn("[Hauntlet ACTION] Executing interior load and join.")
    
    loadInteriorForJoin("MainMap!Fall")
    task.wait(1) 
    
    local joinRemote = game:GetService("ReplicatedStorage"):WaitForChild("API", 5):WaitForChild("HalloweenEventAPI/JoinMinigame", 5)
    if joinRemote then
        local success, result = pcall(function() return joinRemote:InvokeServer() end)
        if success and result and result.success then
            warn("[Hauntlet] Server Invocation SUCCESS! Entering minigame.")
            return true
        else
            warn("[Hauntlet] Server Invocation FAILED. Result: " .. tostring(result))
        end
    end
    
    plr.Character:WaitForChild("HumanoidRootPart").CFrame = oldPos
    return false
end

local function autoClaimTreatBag()
    local function claimBag()
        warn("[TreatBag] Attempting to claim Treat Bag...")
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Xenijo/AdoptMe-RemoteBypass/main/Bypass.lua"))()
        task.wait(0.1)
        
        local success, result = pcall(function()
            return game:GetService("ReplicatedStorage"):WaitForChild("API"):WaitForChild("HalloweenEventAPI/ClaimTreatBag"):InvokeServer()
        end)
        
        if success then warn("[TreatBag] Claim successful.")
        else warn("[TreatBag] Claim failed: " .. tostring(result)) end
    end

    claimBag()
    while task.wait(600) do
        claimBag()
    end
end

local function autoJoinPoller()
    if not liveopstime or not getminigametable then
        warn("[Hauntlet] ERROR: Required minigame modules not defined. Cannot poll timer.")
        return 
    end
    
    while task.wait(5) do
        local minigamet = getminigametable()
        local timeUntilJoin = liveopstime.get_time_until(minigamet.join_zone_helper:get_next_time())
        
        if timeUntilJoin and timeUntilJoin <= 30 then
            if tryJoinHauntlet() then
                warn("[Hauntlet] Successfully joined. Poller suspended for 8 minutes.")
                task.wait(8 * 60)
            else
                warn("[Hauntlet] Join failed. Retrying in a bit.")
            end
        end
    end
end

local function getPetKind()
    for id, petData in pairs(inventorydb.pets) do
        if petData and petData.name and getgenv().farmsettings.pet and string.lower(petData.name) == string.lower(getgenv().farmsettings.pet) then
            return id
        end
    end
    return ""
end

local function isPetOwner(kind)
    for _, petData in pairs(cd.get("inventory").pets) do
        if petData.kind == kind then
            return true
        end
    end
    return false
end

local function getPetId()
    local highestAge = 0
    local highestFriendship = 0
    local petKind = getPetKind()
    
    if getgenv().farmsettings.prioritizeeggs then
        local foundEgg = false
        for petId, petData in pairs(cd.get("inventory").pets) do
            if inventorydb.pets[petData.kind] and inventorydb.pets[petData.kind].is_egg then
                foundEgg = true
                if petKind ~= "" and petData.kind == petKind then return petId
                elseif petKind == "" then return petId end
            end
        end
        
        if not foundEgg then
            if getgenv().farmsettings.pet and string.lower(getgenv().farmsettings.pet) == "aztec egg" then
                if buyAztecEggs() > 0 then
                    task.wait(2)
                    for petId, petData in pairs(cd.get("inventory").pets) do
                        if inventorydb.pets[petData.kind] and string.lower(inventorydb.pets[petData.kind].name) == "aztec egg" then
                            return petId
                        end
                    end
                end
            end
            getgenv().farmsettings.prioritizeeggs = false -- Disable if no eggs found/bought
        end
    end
    
    if #cd.get("inventory").pets == 1 then
		return next(cd.get("inventory").pets)
	end
    
    for _, petData in pairs(cd.get("inventory").pets) do
        if petData.properties and petData.properties.age and petData.properties.age > highestAge and petData.id ~= "practice_dog" then
            highestAge = petData.properties.age
        end
        if petData.properties and petData.properties.friendship_level and petData.properties.friendship_level > highestFriendship then
            highestFriendship = petData.properties.friendship_level
        end
    end
    
    for petId, petData in pairs(cd.get("inventory").pets) do
        if petKind ~= "" and petData.kind == petKind then return petId
        elseif petKind ~= "" and isPetOwner(petKind) then continue end
        
        if highestFriendship > 0 then
            if petData.properties and petData.properties.friendship_level == highestFriendship then return petId
            else continue end
        end
        
        if petData.properties and petData.properties.age == 6 and not getgenv().farmsettings.switchpetsongrown and petData.id ~= "practice_dog" then return petId
        elseif highestAge == 0 and petData.id ~= "practice_dog" then return petId
        elseif petData.properties and petData.properties.age == highestAge and petData.id ~= "practice_dog" then return petId end
    end
    
    warn("No suitable pet found.")
    return nil
end

local function getAilments(ailmentType, pet)
    if ailmentType == "baby" then
        return cd.get("ailments_manager").baby_ailments or {}
    else
        return cd.get("ailments_manager").ailments[pet] or {}
    end
end

local function getPetChar(pet)
    local petEntities = debug.getupvalue(petentitymanager.get_pet_entity, 1)
    for char, entity in pairs(petEntities) do
        if entity.unique_id == pet.."-"..tostring(plr.UserId) then
            return char
        end
    end
end

local function useStroller(pet)
    local strollerId
    for id, data in pairs(cd.get("inventory").strollers) do
        if data.kind == "stroller-default" then strollerId = id; break end
    end
    if not strollerId then return end

    router.get("ToolAPI/Equip"):InvokeServer(strollerId)
    if not plr.Character:WaitForChild("StrollerTool", 3) then useStroller(pet); return end
    
    local args = { plr, getPetChar(pet), plr.Character.StrollerTool.ModelHandle.TouchToSits.TouchToSit }
    router.get("AdoptAPI/UseStroller"):InvokeServer(unpack(args))
end

local function unequipStroller(pet)
    local strollerId
    for id, data in pairs(cd.get("inventory").strollers) do
        if data.kind == "stroller-default" then strollerId = id; break end
    end
    if not strollerId then return end

    router.get("AdoptAPI/EjectBaby"):FireServer(getPetChar(pet))
    router.get("ToolAPI/Unequip"):InvokeServer(strollerId)
end

local function randomMove()
    local rootPart = plr.Character:WaitForChild("HumanoidRootPart")
    local originalPos = rootPart.Position
    plr.Character.Humanoid:MoveTo(originalPos + Vector3.new(-10, 0, 0))
    task.wait(0.5)
    plr.Character.Humanoid:MoveTo(originalPos + Vector3.new(10, 0, 0))
    task.wait(0.5)
    plr.Character.Humanoid:MoveTo(originalPos)
end

local function resetPet(pet)
    router.get("ToolAPI/Unequip"):InvokeServer(pet)
    task.wait(0.1)
    router.get("ToolAPI/Equip"):InvokeServer(pet)
end

local function buyFurnitureWithRetry(id, props)
    local function furnitureExists()
        for _, furniture in pairs(cd.get("house_interior").furniture) do
            if furniture.id == id and furniture.cframe == props.cframe then return true end
        end
        return false
    end

    local args = { {{ properties = props, kind = id }} }
    router.get("HousingAPI/BuyFurnitures"):InvokeServer(unpack(args))
    task.wait(0.1)
    if not furnitureExists() then
        warn("Couldn't buy furniture, retrying")
        buyFurnitureWithRetry(id, props)
    end
end	

local function getFurnitures()
    local furnitureIds = { "toilet", "modernshower", "ailments_refresh_2024_cheap_food_bowl", "ailments_refresh_2024_cheap_water_bowl", "cheapbathtub", "basiccrib", "lures_2023_normal_lure" }
    local furnitureToId = {}
    
    for _, furnitureId in ipairs(furnitureIds) do
        local found = false
        for dbId, data in pairs(cd.get("house_interior").furniture) do
            if data.id == furnitureId then
                furnitureToId[furnitureId] = dbId
                found = true
                break
            end
        end
        if not found then
            buyFurnitureWithRetry(furnitureId, {cframe = CFrame.new(0, 0, 0)})
            task.wait(0.1)
            for dbId, data in pairs(cd.get("house_interior").furniture) do
                if data.id == furnitureId then
                    furnitureToId[furnitureId] = dbId
                    break
                end
            end
        end
    end
    return furnitureToId
end

local function get_items_of_kind(kind, category)
	local items = {}
	for i,v in cd.get("inventory")[category] do
		if v.id == kind then table.insert(items, v) end
	end
	return items
end

local function useBone()
    local boneId
    for id, data in pairs(cd.get("inventory").toys) do
        if data.kind == "squeaky_bone_default" then boneId = id; break end
    end
    if not boneId then return end
    
    local args = { "__Enum_PetObjectCreatorType_1", { reaction_name = "ThrowToyReaction", unique_id = boneId } }
    router.get("PetObjectAPI/CreatePetObject"):InvokeServer(unpack(args))
end

local function setupTeleportHook()
    local soaux = loadstring(game:HttpGet("https://raw.githubusercontent.com/0Void2391/Sulfoxide/refs/heads/main/soaux.lua"))()
    local constants = { "settings", "touch_to_enter", "destination_id", "current_location", "player_about_to_be_unanchored" }
    local func = soaux.searchClosure(ReplicatedStorage.ClientModules.Core.InteriorsM.InteriorsM, "unanchor_and_teleport_player_async", constants)
    
    local old; old = hookfunction(func, function(var)
        if getgenv().teleport == false then return end
        return old(var)
    end)
end

local function loadInterior(interiorType, teleport, name)
    setthreadidentity(2)
    local enter = require(ReplicatedStorage.Fsys).load("InteriorsM").enter
    getgenv().teleport = teleport
    
    if interiorType == "interior" then
		if not workspace.Interiors:GetChildren()[1] or not string.find(workspace.Interiors:GetChildren()[1].Name,name) then
			enter(name, "", {})
		end
    elseif interiorType == "house" then 
		if not workspace.HouseInteriors.blueprint:FindFirstChild(plr.Name) then
        	enter("housing", "MainDoor", {house_owner = name})
		end
    end
    setthreadidentity(8)
end

local function useFurniture(furniture, char)
    local furnitureToId = getFurnitures()
    local id = furnitureToId[furniture]
    local args = { plr, id, furniture == "toilet" and "Seat1" or "UseBlock", { cframe = plr.Character:WaitForChild("HumanoidRootPart").CFrame }, char }
    router.get("HousingAPI/ActivateFurniture"):InvokeServer(unpack(args))
end

local function heal()
    repeat task.wait() until cd.get("house_interior").furniture ~= nil
    for furnitureId, furnitureData in pairs(cd.get("house_interior").furniture) do
        if furnitureData.id == "doctor" then
            local args = { furnitureId, "UseBlock", "Yes", plr.Character }
            router.get("HousingAPI/ActivateInteriorFurniture"):InvokeServer(unpack(args))
        end
    end
end

local function refillFood()
    loadInterior("interior", false, "PizzaShop")
    task.wait(0.2)
    for _ = 1, 20 do
        local args = { "f-12", "Ham", nil, plr.Character }
        router.get("HousingAPI/ActivateInteriorFurniture"):InvokeServer(unpack(args))
    end
end

local function eatFood()
    local ham
    for foodId, foodData in pairs(cd.get("inventory").food) do
        if foodData.kind == "pizza_shop_ham" then ham = foodId; break end
    end
    if not ham then
        refillFood()
        for foodId, foodData in pairs(cd.get("inventory").food) do
            if foodData.kind == "pizza_shop_ham" then ham = foodId; break end
        end
    end
    if not ham then return end
    router.get("ToolAPI/ServerUseTool"):FireServer(ham, "START")
    task.wait(0.5)
    router.get("ToolAPI/ServerUseTool"):FireServer(ham, "END")
end

local function refillWater()
    loadInterior("interior", false, "PizzaShop")
    task.wait(0.2)
    for _ = 1, 20 do
        local args = { "f-90", "UseBlock", nil, plr.Character }
        router.get("HousingAPI/ActivateInteriorFurniture"):InvokeServer(unpack(args))
    end
end

local function drinkWater()
    local water
    for foodId, foodData in pairs(cd.get("inventory").food) do
        if foodData.kind == "water_paper_cup" then water = foodId; break end
    end
    if not water then
        refillWater()
        for foodId, foodData in pairs(cd.get("inventory").food) do
            if foodData.kind == "water_paper_cup" then water = foodId; break end
        end
    end
    if not water then return end
    router.get("ToolAPI/ServerUseTool"):FireServer(water, "START")
    task.wait(0.5)
    router.get("ToolAPI/ServerUseTool"):FireServer(water, "END")
end

local function solveMysteryEnhanced(pet)
    if not cd.get("ailments_manager") or not cd.get("ailments_manager").ailments or not cd.get("ailments_manager").ailments[pet] then return nil end

    local success, result = pcall(function()
        setthreadidentity(2)
        local WeightedRandom = require(ReplicatedStorage.new.modules.Utilities.WeightedRandom)
        local LegacyLoad = require(ReplicatedStorage.new.modules.LegacyLoad)
        local CloudValues = LegacyLoad("CloudValues")
        local MysteryHelper = require(ReplicatedStorage.new.modules.Ailments.Helpers.MysteryHelper)
        
        local mystery = cd.get("ailments_manager").ailments[pet].mystery
        if not mystery or not mystery.components then return nil end
        
        local components = MysteryHelper.get_action(mystery)
        if not components or not components.options then return nil end
        
        local seed = components.options.random_seed
        local get_ailment_slots = components.options.get_ailment_slots
        if not seed or not get_ailment_slots then return nil end
        
        local function get_slot_categories(v11)
            local weights = CloudValues:getValue("ailments", "mysteryAilmentCategoryWeights")
            if not weights then return nil end
            return WeightedRandom.get_values(weights, 3, v11)
        end
        
        local petTable
        for _, v in pairs(getgc(true)) do
            if typeof(v) == "table" and rawget(v, "pet_id") and rawget(v, "player") == plr then
                petTable = v; break
            end
        end
        if not petTable then return nil end
        
        local slots = get_slot_categories(seed)
        if not slots then return nil end
        
        return get_ailment_slots(seed, slots, petTable)
    end)
    setthreadidentity(8)
    
    if not success then warn("[MYSTERY] Error: " .. tostring(result)) return nil end
    return result
end

local function antiAFK()
    if getconnections then
        for _, connection in pairs(getconnections(plr.Idled)) do
            if connection.Disable then connection:Disable() elseif connection.Disconnect then connection:Disconnect() end
        end
    else
        local VirtualUser = cloneref(game:GetService("VirtualUser"))
        plr.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end
end

local startAutoFarm
local function waitForAilmentFinish(ailment, callback, ailmentType, pet)
    local started = tick()
    repeat 
        task.wait()
        if callback then callback() end
        
        local ailments = getAilments(ailmentType, pet)
        if not ailments[ailment] then break end
        
        if tick() - started >= 70 then
            warn("Task timed out, restarting autofarm...")
            task.spawn(startAutoFarm)
            coroutine.yield()
        end
    until not getAilments(ailmentType, pet)[ailment]
end

local ailmentFunctions = {
["scale_the_organ"] = function(pet, ailmentType)
    loadInterior("interior", false, "MainMap!Fall")
    task.wait(0.5)
    local step_positions = {
        Vector3.new(-335.31, 33.05, -1448.59), Vector3.new(-338.49, 34.48, -1447.55),
        Vector3.new(-343.19, 36.64, -1446.23), Vector3.new(-345.65, 38.63, -1442.83),
        Vector3.new(-349.2, 40.55, -1439.78), Vector3.new(-350.44, 42.8, -1435.09),
        Vector3.new(-351.23, 44.26, -1431.61), Vector3.new(-350.76, 46.42, -1426.64),
        Vector3.new(-348.43, 48.89, -1421.59), Vector3.new(-345.55, 50.33, -1419.6),
        Vector3.new(-341.97, 52.25, -1417.48), Vector3.new(-337.78, 54.32, -1415.81),
        Vector3.new(-333.76, 56.16, -1414.92), Vector3.new(-328.45, 58.66, -1415.77),
        Vector3.new(-324.91, 60.22, -1417), Vector3.new(-321.42, 62.31, -1420.06),
        Vector3.new(-319.07, 64.12, -1423.32), Vector3.new(-318.95, 65.77, -1426.79),
        Vector3.new(-318.72, 68.21, -1431.8), Vector3.new(-318.53, 70.24, -1436.03),
        Vector3.new(-319.19, 71.85, -1439.38), Vector3.new(-321.86, 74.05, -1443.46),
        Vector3.new(-325.87, 76.42, -1446.56), Vector3.new(-329.74, 78.31, -1448.4),
        Vector3.new(-333.65, 80.09, -1449.11), Vector3.new(-337.63, 82.19, -1446.86),
        Vector3.new(-341.83, 84.57, -1444.76), Vector3.new(-345.98, 86.8, -1442.68), 
        Vector3.new(-350.2, 89.1, -1440.5),
    }
    local rootPart = plr.Character:WaitForChild("HumanoidRootPart")
    local oldPos = rootPart.CFrame
    resetPet(pet)
    task.wait(0.5)
    for _, position in ipairs(step_positions) do
        rootPart.CFrame = CFrame.new(position) + Vector3.new(0, 3, 0)
        task.wait(1.5)
    end
    task.wait(1)
    waitForAilmentFinish("scale_the_organ", nil, ailmentType, pet)
    rootPart.CFrame = oldPos
end,
    ["toilet"] = function(pet)
        loadInterior("house", false, plr)
        resetPet(pet)
        task.wait(0.2)
        task.spawn(useFurniture, "toilet", getPetChar(pet))
        waitForAilmentFinish("toilet", nil, "pet", pet)
    end,
    ["hungry"] = function(pet)
        loadInterior("house", false, plr)
        resetPet(pet)
        task.wait(0.2)
        task.spawn(useFurniture, "ailments_refresh_2024_cheap_food_bowl", getPetChar(pet))
        waitForAilmentFinish("hungry", nil, "pet", pet)
    end,
    ["sick"] = function(pet, ailmentType)
        loadInterior("interior", false, "Hospital")
        task.wait(0.5)
        heal()
        waitForAilmentFinish("sick", nil, ailmentType, pet)
    end,
    ["thirsty"] = function(pet)
        loadInterior("house", false, plr)
        resetPet(pet)
        task.wait(0.2)
        task.spawn(useFurniture, "ailments_refresh_2024_cheap_water_bowl", getPetChar(pet))
        waitForAilmentFinish("thirsty", nil, "pet", pet)
    end,
    ["sleepy"] = function(pet)
        loadInterior("house", false, plr)
        resetPet(pet)
        task.wait(0.2)
        task.spawn(useFurniture, "basiccrib", getPetChar(pet))
        waitForAilmentFinish("sleepy", nil, "pet", pet)
    end,
    ["camping"] = function(pet, ailmentType)
        loadInterior("interior", false, "MainMap")
		local oldPos = plr.Character:WaitForChild("HumanoidRootPart").CFrame
		plr.Character.HumanoidRootPart.CFrame = CFrame.new(workspace.StaticMap.Campsite.CampsiteOrigin.Position + Vector3.new(0, 3, 0))
        task.wait(0.2)
        resetPet(pet)
        waitForAilmentFinish("camping", nil, ailmentType, pet)
        plr.Character.HumanoidRootPart.CFrame = oldPos
    end,
    ["bored"] = function(pet, ailmentType)
        loadInterior("interior", false, "MainMap")
		local oldPos = plr.Character:WaitForChild("HumanoidRootPart").CFrame
		plr.Character.HumanoidRootPart.CFrame = CFrame.new(workspace.StaticMap.Park.BoredAilmentTarget.Position + Vector3.new(0, 2, 0))
        task.wait(0.2)
        resetPet(pet)
        waitForAilmentFinish("bored", nil, ailmentType, pet)
        plr.Character.HumanoidRootPart.CFrame = oldPos
    end,
    ["salon"] = function(pet, ailmentType)
        loadInterior("interior", false, "Salon")
        waitForAilmentFinish("salon", nil, ailmentType, pet)
    end,
    ["play"] = function(pet)
        resetPet(pet)
        waitForAilmentFinish("play", function() useBone(); task.wait(10.5) end, "pet", pet)
    end,
    ["beach_party"] = function(pet, ailmentType)
        loadInterior("interior", false, "MainMap")
		local oldPos = plr.Character:WaitForChild("HumanoidRootPart").CFrame
		plr.Character.HumanoidRootPart.CFrame = CFrame.new(workspace.Interiors:FindFirstChildWhichIsA("Model").Buildings.BeachShop.Visual.BeachShopSetDressing:GetPivot().Position)
        task.wait(0.2)
        resetPet(pet)
        waitForAilmentFinish("beach_party", nil, ailmentType, pet)
        plr.Character.HumanoidRootPart.CFrame = oldPos
    end,
    ["ride"] = function(pet)
        plr.Character.HumanoidRootPart.CFrame = CFrame.new(100, 1002, 100)
        resetPet(pet)
        useStroller(pet)
        waitForAilmentFinish("ride", randomMove, "pet", pet)
        unequipStroller(pet)
    end,
    ["dirty"] = function(pet)
        loadInterior("house", false, plr)
        task.spawn(useFurniture, "modernshower", getPetChar(pet))
        waitForAilmentFinish("dirty", nil, "pet", pet)
        resetPet(pet)
    end,
    ["walk"] = function(pet)
		router.get("AdoptAPI/HoldBaby"):FireServer(getPetChar(pet))
        waitForAilmentFinish("walk", randomMove, "pet", pet)
		router.get("AdoptAPI/EjectBaby"):FireServer(getPetChar(pet))
		plr.Character.HumanoidRootPart.CFrame = CFrame.new(100, 1002, 100)
    end,
    ["pet_me"] = function(pet)
        plr.Character.HumanoidRootPart.CFrame = CFrame.new(100, 1002, 100)
        resetPet(pet)
        task.wait(0.5)
        
        local petChar = getPetChar(pet)
        local function complete()
            if petChar and petChar:FindFirstChild("HumanoidRootPart") then
                local viewportPoint = workspace.CurrentCamera:WorldToViewportPoint(petChar.HumanoidRootPart.Position)
                local vim = game:GetService("VirtualInputManager")
                vim:SendMouseButtonEvent(viewportPoint.X, viewportPoint.Y, 0, true, game, 1)
                task.wait(0.05)
                vim:SendMouseButtonEvent(viewportPoint.X, viewportPoint.Y, 0, false, game, 1)
                task.wait(0.3)
                router.get("AilmentsAPI/ProgressPetMeAilment"):FireServer(pet)
            end
        end
        waitForAilmentFinish("pet_me", complete, "pet", pet)
        
        pcall(function()
            local backButton = plr.PlayerGui.FocusPetApp.Frame.BackButton
            if backButton then firesignal(backButton.MouseButton1Click) end
        end)
    end,
    ["school"] = function(pet, ailmentType)
        loadInterior("interior", false, "School")
        waitForAilmentFinish("school", nil, ailmentType, pet)
    end,
    ["mystery"] = function(pet)
        local solved = solveMysteryEnhanced(pet)
        if not solved then warn("[MYSTERY] Solver failed, skipping."); return end
        
        for choice = 1, 3 do
            if solved[choice] then
                if pcall(function() router.get("AilmentsAPI/ChooseMysteryAilment"):FireServer(pet, "mystery", choice, solved[choice]) end) then break end
            end
        end
        waitForAilmentFinish("mystery", nil, "pet", pet)
    end,
    ["pizza_party"] = function(pet, ailmentType)
        loadInterior("interior", false, "PizzaShop")
        waitForAilmentFinish("pizza_party", nil, ailmentType, pet)
    end
}

local babyAilmentsFunctions = {
    ["hungry"] = function() waitForAilmentFinish("hungry", eatFood, "baby") end,
    ["thirsty"] = function() waitForAilmentFinish("thirsty", drinkWater, "baby") end,
    ["sleepy"] = function()
        loadInterior("house", false, plr)
        task.spawn(useFurniture, "basiccrib", plr.Character)
        waitForAilmentFinish("sleepy", nil, "baby")
        router.get("PetAPI/ExitFurnitureUseStates"):InvokeServer()
        router.get("AdoptAPI/ExitSeatStates"):FireServer()
    end,
    ["dirty"] = function()
        loadInterior("house", false, plr)
        task.spawn(useFurniture, "modernshower", plr.Character)
        waitForAilmentFinish("dirty", nil, "baby")
        router.get("PetAPI/ExitFurnitureUseStates"):InvokeServer()
        router.get("AdoptAPI/ExitSeatStates"):FireServer()
    end
}

local function handlelures()
	loadInterior("house", false, plr)
	getFurnitures()
	local bait = get_items_of_kind("ice_dimension_2025_shiver_cone_bait", "food")[1] or get_items_of_kind("ice_dimension_2025_ice_soup_bait", "food")[1]
	local lure = cd.get("house_interior").furniture[getFurnitures()["lures_2023_normal_lure"]]
	if lure.lure and lure.lure.finished and lure.lure.reward then
		router.get("HousingAPI/ActivateFurniture"):InvokeServer(plr, getFurnitures()["lures_2023_normal_lure"], "UseBlock", { bait_unique = nil }, plr.Character)
	end
	if not lure.lure and bait then 
		router.get("HousingAPI/ActivateFurniture"):InvokeServer(plr, getFurnitures()["lures_2023_normal_lure"], "UseBlock", { bait_unique = bait.unique }, plr.Character)
	end
end

local function questhandler()
	for i,v in pairs(cd.get("quest_manager").quests_cached) do
		if v.steps_completed >= 1 then router.get("QuestAPI/ClaimQuest"):InvokeServer(i) end
	end
end

startAutoFarm = function()
    plr.Character:FindFirstChild("HumanoidRootPart").CFrame = CFrame.new(100, 1002, 100)
    task.wait(0.4)
    
    local currentPetId = getPetId()
    if not currentPetId then warn("No pet found to start farming. Stopping."); return end
    resetPet(currentPetId)
    warn("Starting autofarm with pet: " .. currentPetId)
    
    for i = 1, 17 do
		if not cd.get("daily_login_manager").claimed_star_rewards["reward_"..i] then
			router.get("DailyLoginAPI/ClaimStarReward"):InvokeServer("reward_"..i)
			break
		end
	end
	router.get("DailyLoginAPI/ClaimDailyReward"):InvokeServer()
    
    while task.wait() do
        local petExists = cd.get("inventory").pets[currentPetId]
        local currentPetData = petExists and cd.get("inventory").pets[currentPetId]
        
        local shouldSwitchPet = not petExists
        if currentPetData and currentPetData.properties then
            if currentPetData.properties.age == 6 and getgenv().farmsettings.switchpetsongrown then
                shouldSwitchPet = true
            end
            if inventorydb.pets[currentPetData.kind] and not inventorydb.pets[currentPetData.kind].is_egg and getgenv().farmsettings.prioritizeeggs then
                shouldSwitchPet = true
            end
        end
        
        if shouldSwitchPet then
            local newPetId = getPetId()
            if newPetId and newPetId ~= currentPetId then
                warn("Switching from pet " .. currentPetId .. " to " .. newPetId)
                resetPet(newPetId)
                currentPetId = newPetId
            elseif not newPetId then
                warn("Could not find a new pet to switch to. Stopping.")
                return
            end
        else
             router.get("ToolAPI/Equip"):InvokeServer(currentPetId)
        end

        questhandler()
        
        warn("Waiting for tasks...")
        for ailment, _ in pairs(getAilments("pet", currentPetId)) do
            task.wait(0.1)
            warn("Current task: " .. ailment)
            ailmentFunctions[ailment](currentPetId, "pet")
        end
        
        if getgenv().farmsettings.babyfarm then
            for ailment, _ in pairs(getAilments("baby")) do
                task.wait(0.1)
                warn("Current task: baby " .. ailment)
                if babyAilmentsFunctions[ailment] then
                    babyAilmentsFunctions[ailment]()
                elseif ailmentFunctions[ailment] then
                     ailmentFunctions[ailment](nil, "baby")
                end
            end
        end
        handlelures()
    end
end

local function init()
	if getgenv().farmsettings.babyfarm then
		router.get("TeamAPI/ChooseTeam"):InvokeServer("Babies", { dont_respawn = true, source_for_logging = "avatar_editor" })
	end
    setupTeleportHook()
    local baseplate = Instance.new("Part", workspace)
    baseplate.Size = Vector3.new(100, 2, 100)
    baseplate.CFrame = CFrame.new(100, 1000, 100)
    baseplate.Anchored = true
    
    getgenv().running = true
    antiAFK()
    task.spawn(autoClaimTreatBag)
    task.spawn(autoJoinPoller)

	if not (#get_items_of_kind("trade_license", "toys") > 0) then
        warn("Completing trade license quiz...")
		loadInterior("interior", true, "SafetyHub")
		router.get("SettingsAPI/SetBooleanFlag"):FireServer("has_talked_to_trade_quest_npc", true)
		loadInterior("interior", true, "TradeLicenseZone")
		router.get("TradeAPI/BeginQuiz"):FireServer()
		repeat task.wait() until cd.get("trade_license_quiz_manager")
		for i = 1, 3 do
			router.get("TradeAPI/AnswerQuizQuestion"):FireServer(cd.get("trade_license_quiz_manager").quiz[i].answer)
		end
        warn("Trade license quiz completed.")
	end
    startAutoFarm()
end

task.wait(7)
init()
