-- Adopt Me Zotti Autofarm by 0_Void (Optimized Version)
getgenv().farmsettings = {
    pet = "", -- Leave blank for auto-select
    babyfarm = true,
    switchpetsongrown = false, -- False for age potions
	prioritizeeggs = false,
	gui = true,
}
--writefile("adoptmeautofarm.txt")
if getgenv().running then 
    warn("Script already running")
    return 
end
getgenv().running = true

repeat task.wait() until game:IsLoaded()
local t = require(game:GetService("ReplicatedStorage"):WaitForChild("ClientModules").Game.Tutorial.LegacyTutorial)
hookfunction(t.run_avatar_tutorial,function()end)
hookfunction(t.run_housing_tutorial,function()end)
hookfunction(t.run_nursery_tutorial,function()end)

-- Set default settings if not provided
getgenv().farmsettings = getgenv().farmsettings or {
    pet = "Aztec Egg",
    babyfarm = true,
    switchpetsongrown = true,
    prioritizeeggs = false,
	gui = true
}

-- Initialize settings with defaults
getgenv().farmsettings.pet = getgenv().farmsettings.pet or ""
getgenv().farmsettings.babyfarm = getgenv().farmsettings.babyfarm == nil and true or getgenv().farmsettings.babyfarm
getgenv().farmsettings.switchpetsongrown = if getgenv().farmsettings.switchpetsongrown == nil then false else getgenv().farmsettings.switchpetsongrown
getgenv().farmsettings.prioritizeeggs = if getgenv().farmsettings.prioritizeeggs == nil then false else getgenv().farmsettings.prioritizeeggs
getgenv().farmsettings.gui = getgenv().farmsettings.gui == nil and true or getgenv().farmsettings.gui
-- Wait for game to load
repeat task.wait() until game:IsLoaded()
task.wait(5)
setthreadidentity(2)
-- Services and modules
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local CoreGui = game:GetService("CoreGui")
local plr = Players.LocalPlayer
local router = require(ReplicatedStorage.ClientModules.Core.RouterClient.RouterClient)
local cd = require(ReplicatedStorage.ClientModules.Core.ClientData)
local petentitymanager = require(ReplicatedStorage.ClientModules.Game.PetEntities.PetEntityManager)
local inventorydb = require(ReplicatedStorage.ClientDB.Inventory.InventoryDB)

local terrainhelper = require(game:GetService("ReplicatedStorage").SharedModules.TerrainHelper)
local Fsys = require(ReplicatedStorage.Fsys)
local liveopstime = Fsys.load("LiveOpsTime")
setthreadidentity(8)
if plr.Character == nil then
	router.get("LegacyTutorialAPI/MarkTutorialCompleted"):FireServer()
	router.get("LegacyTutorialAPI/EquipTutorialEgg"):FireServer()
    repeat 
        local playbutton = game:GetService("Players").LocalPlayer.PlayerGui.NewsApp.EnclosingFrame.MainFrame.Buttons.PlayButton
        firesignal(playbutton.MouseButton1Down)
        firesignal(playbutton.MouseButton1Up)
        firesignal(playbutton.MouseButton1Click)
        task.wait(1)
		if game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Visible then
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Info.Response:GetChildren()[8].MouseButton1Down)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Info.Response:GetChildren()[8].MouseButton1Up)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Info.Response:GetChildren()[8].MouseButton1Click)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Buttons.ButtonTemplate.MouseButton1Down)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Buttons.ButtonTemplate.MouseButton1Up)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Buttons.ButtonTemplate.MouseButton1Click)
        else
			firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.SpawnChooserDialog.UpperCardContainer.ChoicesContent.Choices.Home.Button.MouseButton1Down)
			firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.SpawnChooserDialog.UpperCardContainer.ChoicesContent.Choices.Home.Button.MouseButton1Up)
			firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.SpawnChooserDialog.UpperCardContainer.ChoicesContent.Choices.Home.Button.MouseButton1Click)
		end
    until not (plr.Character == nil)
end
-- GUI Creation
local function createGUI()
    local screenGui = Instance.new("ScreenGui", CoreGui) -- OPTIMIZATION: Parent to CoreGui for better performance
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.DisplayOrder = -1
    screenGui.ResetOnSpawn = false
    screenGui.Archivable = false -- OPTIMIZATION: Exclude from saving, minor memory benefit

    local mainFrame = Instance.new("Frame", screenGui)
    mainFrame.BorderSizePixel = 0
    mainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    mainFrame.BackgroundTransparency = 1 
    mainFrame.Size = UDim2.new(1, 0, 1, 100)
    mainFrame.Position = UDim2.new(0, 0, -0.1, 0)
    mainFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
    mainFrame.Visible = getgenv().farmsettings.gui
    mainFrame.Archivable = false

    local title = Instance.new("TextLabel", mainFrame)
    title.BorderSizePixel = 0
    title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    title.BackgroundTransparency = 1 
    title.TextSize = 84
    title.FontFace = Font.new("rbxasset://fonts/families/Zekton.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal)
    title.TextColor3 = Color3.fromRGB(50, 150, 255) 
    title.Size = UDim2.new(0, 260, 0, 82)
    title.BorderColor3 = Color3.fromRGB(0, 0, 0)
    title.Text = "Zotti autofarm"
    title.Name = "Title"
    title.Position = UDim2.new(0.45, 0, 0.116, 0)
    title.Archivable = false

    local labels = {
        {name = "Pet", text = "Current pet: None", position = UDim2.new(-0.57227, 0, 1.93902, 0)},
        {name = "Task", text = "Current task: None", position = UDim2.new(-0.57227, 0, 2.54878, 0)},
        {name = "Money", text = "Money farmed: 0", position = UDim2.new(-0.57227, 0, 3.15854, 0)},
        {name = "Potions", text = "Gained potions: 0", position = UDim2.new(-0.57227, 0, 4.37805, 0)},
        {name = "Time", text = "Time elapsed: 00:00", position = UDim2.new(-0.57227, 0, 4.9878, 0)}
    }

    for _, labelInfo in ipairs(labels) do
        local label = Instance.new("TextLabel", title)
        label.BorderSizePixel = 0
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        label.BackgroundTransparency = 1 
        label.TextSize = 33
        label.FontFace = Font.new("rbxasset://fonts/families/Zekton.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal)
        label.TextColor3 = Color3.fromRGB(50, 150, 255) 
        label.Size = UDim2.new(0, 533, 0, 50)
        label.BorderColor3 = Color3.fromRGB(0, 0, 0)
        label.Text = labelInfo.text
        label.Name = labelInfo.name
        label.Position = labelInfo.position
        label.Archivable = false
    end

    return screenGui
end
local gui = createGUI()

-- New function to buy Aztec Eggs
local function buyAztecEggs()
    local eggsBought = 0
    local maxEggs = 50
    
    warn("[DEBUG] buyAztecEggs() called")
    warn("[DEBUG] Current money: " .. tostring(cd.get("money")))
    
    for i = 1, maxEggs do
        warn("[DEBUG] Attempting to buy egg #" .. i)
        
        local success, result = pcall(function()
            local args = {"pets", "aztec_egg_2025_aztec_egg", {}}
            local response = game:GetService("ReplicatedStorage").API:FindFirstChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
            warn("[DEBUG] Shop response: " .. tostring(response))
            return response
        end)
        
        if success then
            if result then
                eggsBought = eggsBought + 1
                warn("[DEBUG] Successfully bought Aztec Egg #" .. eggsBought)
                warn("[DEBUG] Money after purchase: " .. tostring(cd.get("money")))
                task.wait(0.5) -- Wait for inventory to update
                
                -- Check if we actually got an egg in inventory
                local hasNewEgg = false
                local inventoryPets = cd.get("inventory").pets
                for petId, petData in pairs(inventoryPets) do
                    if inventorydb.pets[petData.kind] and inventorydb.pets[petData.kind].name == "Aztec Egg" then
                        hasNewEgg = true
                        warn("[DEBUG] Confirmed Aztec Egg in inventory: " .. petId)
                        break
                    end
                end
                
                if hasNewEgg then
                    warn("[DEBUG] Successfully confirmed egg purchase")
                    return eggsBought -- Return immediately after successful purchase
                else
                    warn("[DEBUG] Purchase successful but no egg found in inventory")
                end
            else
                warn("[DEBUG] Shop returned false/nil - likely insufficient funds or unavailable")
                break
            end
        else
            warn("[DEBUG] Failed to buy Aztec Egg #" .. i .. ": " .. tostring(result))
            break -- Stop trying if we get an error
        end
        
        -- Stop if we've tried 3 times without getting an egg
        if i >= 3 and eggsBought == 0 then
            warn("[DEBUG] Tried 3 times without success, stopping purchase attempts")
            break
        end
    end
    
    warn("[DEBUG] Finished buying process. Total successful purchases: " .. eggsBought)
    return eggsBought
end

-- Modified function to check if we have the specified egg
local function hasSpecifiedEgg()
    if not getgenv().farmsettings.pet or getgenv().farmsettings.pet == "" then
        return true -- No specific pet required
    end
    
    local inventoryPets = cd.get("inventory").pets
    for petId, petData in pairs(inventoryPets) do
        if inventorydb.pets[petData.kind] and inventorydb.pets[petData.kind].name and 
           string.lower(inventorydb.pets[petData.kind].name) == string.lower(getgenv().farmsettings.pet) then
            return true
        end
    end
    return false
end

-- Utility Functions
local function formatTime(elapsedTime)
    local hours = math.floor(elapsedTime / 3600)
    local minutes = math.floor((elapsedTime % 3600) / 60)
    return string.format("%02d:%02d", hours, minutes)
end
-- Define minigame helper functions based on your script's structure
-- The most common and robust way to execute these system calls.
local function loadInteriorForJoin(name)
    -- 1. Ensure the thread has elevated privileges for system calls
    setthreadidentity(2) 
    
    local Fsys = game:GetService("ReplicatedStorage"):WaitForChild("Fsys", 5)
    if not Fsys then warn("[Hauntlet] Fsys module not found.") end
    
    -- 2. Execute the module loading and entry in a single, reliable block
    local success, result = pcall(function()
        local FsysModule = require(Fsys)
        local load = FsysModule.load
        local interiors = load("InteriorsM")
        local enter = interiors.enter
        
        enter(name, "", {})
        
        return true
    end)

    if not success or not result then
        warn(string.format("[Hauntlet] CRITICAL FAILURE: Interior load failed! Error: %s", tostring(result)))
    end
    
    -- 3. Reset identity immediately after the operation
    setthreadidentity(8) 
end

-- New primary function to be called inside your main farming loop.
local function checkAndJoinHauntlet()
    if not liveopstime or not getminigametable then
        return 
    end

    local minigamet = getminigametable()
    local timeUntilJoin = liveopstime.get_time_until(minigamet.join_zone_helper:get_next_time())
    
    if timeUntilJoin and timeUntilJoin > 0 and timeUntilJoin < 30 then
        warn(string.format("[Hauntlet] Join window detected (Time until next join: %d seconds). Initiating join sequence.", timeUntilJoin))
        
        loadInteriorForJoin("MainMap!Fall")
        task.wait(2) 
        
        local joinRemote = game:GetService("ReplicatedStorage"):WaitForChild("API", 5):WaitForChild("HalloweenEventAPI/JoinMinigame", 5)
        if joinRemote then
            local success, result = pcall(function()
                joinRemote:InvokeServer() 
            end)

            if success and result and result.success then
                warn("[Hauntlet] Server Invocation SUCCESS! You should be teleporting now.")
            else
                warn("[Hauntlet] Server Invocation FAILED. Result: " .. tostring(result))
            end
        end
        
        local waitTime = 7 * 60 + 30 
        warn(string.format("[Hauntlet] Join sequence complete. Thread sleeping for ~%d seconds until minigame is over...", waitTime))
        
        task.wait(waitTime) 
        
        warn("[Hauntlet] Minigame wait complete. Resuming autofarm loop.")
        return true
    end
    
    return false
end

local function tryJoinHauntlet()
    local oldPos = plr.Character:WaitForChild("HumanoidRootPart").CFrame
    
    warn("[Hauntlet ACTION] Executing interior load and join.")
    
    loadInteriorForJoin("MainMap!Fall")
    task.wait(1) 
    
    local joinRemote = game:GetService("ReplicatedStorage"):WaitForChild("API", 5):WaitForChild("HalloweenEventAPI/JoinMinigame", 5)
    if joinRemote then
        local success, result = pcall(function()
            joinRemote:InvokeServer() 
        end)

        if success and result and result.success then
            warn("[Hauntlet] Server Invocation SUCCESS! Entering minigame.")
            return true
        else
            warn("[Hauntlet] Server Invocation FAILED. Result: " .. tostring(result))
        end
    end
    
    plr.Character:WaitForChild("HumanoidRootPart").CFrame = oldPos
    return false
end
local function autoClaimTreatBag()
    local function claimBag()
        warn("[TreatBag] Executing remote bypass and claiming Treat Bag...")
        
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Xenijo/AdoptMe-RemoteBypass/main/Bypass.lua"))()
        task.wait(0.1)
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("API"):WaitForChild("HalloweenEventAPI/ClaimTreatBag"):InvokeServer()
        end)
        
        if success and result ~= nil then
             warn("[TreatBag] Claim successful.")
        elseif not success then
             warn("[TreatBag] Claim failed (Bypass may not be loaded or remote changed): " .. tostring(result))
        else
             warn("[TreatBag] Claim completed (Response unknown).")
        end
    end
    claimBag()
    while task.wait(600) do
        claimBag()
    end
end

local function autoJoinPoller()
    if not liveopstime or not getminigametable then
        warn("[Hauntlet] ERROR: liveopstime or getminigametable not defined. Cannot poll minigame timer.")
        return 
    end
    
    while task.wait(5) do
        local minigamet = getminigametable()
        local timeUntilJoin = liveopstime.get_time_until(minigamet.join_zone_helper:get_next_time())
        
        if timeUntilJoin and timeUntilJoin <= 30 then
            local joined = tryJoinHauntlet()
            
            if joined then
                warn("[Hauntlet] Successfully joined minigame. Poller suspended for 8 minutes.")
                task.wait(8 * 60) 
            else
                warn("[Hauntlet] Join failed. Continuing to poll.")
            end
        end
    end
end

local function getPetKind()
    local farmPetName = getgenv().farmsettings.pet
    if not farmPetName then return "" end
    farmPetName = string.lower(farmPetName)

    for id, petData in pairs(inventorydb.pets) do
        if petData and petData.name and string.lower(petData.name) == farmPetName then
            return id
        end
    end
    return ""
end

local function getPetNameFromId(id)
    local inventoryPets = cd.get("inventory").pets
    for petId, petData in pairs(inventoryPets) do
        if petId == id and inventorydb.pets[petData.kind] and inventorydb.pets[petData.kind].name then
            return inventorydb.pets[petData.kind].name
        end
    end
    return ""
end

local function isPetOwner(kind)
    local inventoryPets = cd.get("inventory").pets
    for _, petData in pairs(inventoryPets) do
        if petData.kind == kind then
            return true
        end
    end
    return false
end

local function getPetId()
    local highestAge = 0
    local highestFriendship = 0
    local petKind = getPetKind()
    local inventoryPets = cd.get("inventory").pets
    
    if getgenv().farmsettings.prioritizeeggs then
        local foundEgg = false
        for petId, petData in pairs(inventoryPets) do
            if inventorydb.pets[petData.kind] and inventorydb.pets[petData.kind].is_egg then
                foundEgg = true
                if petKind ~= "" and petData.kind == petKind then
                    return petId
                elseif petKind == "" then
                    return petId
                end
            end
        end
        
        if not foundEgg then
            if getgenv().farmsettings.pet and string.lower(getgenv().farmsettings.pet) == "aztec egg" then
                local bought = buyAztecEggs()
                if bought > 0 then
                    task.wait(2)
                    inventoryPets = cd.get("inventory").pets -- Refresh inventory
                    for petId, petData in pairs(inventoryPets) do
                        if inventorydb.pets[petData.kind] and inventorydb.pets[petData.kind].is_egg and string.lower(inventorydb.pets[petData.kind].name) == "aztec egg" then
                            return petId
                        end
                    end
                else
                    getgenv().farmsettings.prioritizeeggs = false
                end
            else
                getgenv().farmsettings.prioritizeeggs = false
            end
        end
    end
    
    if #inventoryPets == 1 then
		return next(inventoryPets)
	end
    
    for _, petData in pairs(inventoryPets) do
        if petData.properties and petData.properties.age and petData.properties.age > highestAge and petData.id ~= "practice_dog" then
            highestAge = petData.properties.age
        end
        if petData.properties and petData.properties.friendship_level and petData.properties.friendship_level > highestFriendship then
            highestFriendship = petData.properties.friendship_level
        end
    end
    
    for petId, petData in pairs(inventoryPets) do
        if petKind ~= "" and petData.kind == petKind then
            return petId
        elseif petKind ~= "" and isPetOwner(petKind) then
            continue
        end
        
        if highestFriendship > 0 then
            if petData.properties and petData.properties.friendship_level == highestFriendship then
                return petId
            else
                continue
            end
        end
        
        if petData.properties and petData.properties.age == 6 and not getgenv().farmsettings.switchpetsongrown and petData.id ~= "practice_dog" then
            return petId
        elseif highestAge == 0 and petData.id ~= "practice_dog" then 
            return petId
        elseif petData.properties and petData.properties.age == highestAge and petData.id ~= "practice_dog" then
            return petId
        end
    end
    
    return nil
end

local function getAilments(ailmentType, pet)
    local ailmentsManager = cd.get("ailments_manager")
    if ailmentType == "baby" then
        return ailmentsManager.baby_ailments or {}
    else
        return ailmentsManager.ailments[pet] or {}
    end
end

local function getStrollerId()
    for strollerId, strollerData in pairs(cd.get("inventory").strollers) do
        if strollerData.kind == "stroller-default" then
            return strollerId
        end
    end
end

local function getPetChar(pet)
    local petEntities = debug.getupvalue(petentitymanager.get_pet_entity, 1)
    for char, entity in pairs(petEntities) do
        if entity.unique_id == pet.."-"..tostring(plr.UserId) then
            return char
        end
    end
end

local function useStroller(pet)
    router.get("ToolAPI/Equip"):InvokeServer(getStrollerId())
    if not plr.Character:WaitForChild("StrollerTool", 3) then
		useStroller(pet)
		return
	end
    local args = {
		plr,
        getPetChar(pet),
        plr.Character:WaitForChild("StrollerTool").ModelHandle.TouchToSits.TouchToSit
    }
    router.get("AdoptAPI/UseStroller"):InvokeServer(unpack(args))
end

local function unequipStroller(pet)
    router.get("AdoptAPI/EjectBaby"):FireServer(getPetChar(pet))
    router.get("ToolAPI/Unequip"):InvokeServer(getStrollerId())
end

local function randomMove()
    local rootPart = plr.Character:WaitForChild("HumanoidRootPart")
    local currentPos = rootPart.Position
    plr.Character.Humanoid:MoveTo(currentPos + Vector3.new(-10, 0, 0))
    task.wait(0.5)
    plr.Character.Humanoid:MoveTo(currentPos + Vector3.new(10, 0, 0))
    task.wait(0.5)
    plr.Character.Humanoid:MoveTo(currentPos)
end

local function resetPet(pet)
    router.get("ToolAPI/Unequip"):InvokeServer(pet)
    task.wait(0.1)
    router.get("ToolAPI/Equip"):InvokeServer(pet)
end

local function furnitureExists(kind, properties)
    for _, furniture in pairs(cd.get("house_interior").furniture) do
        if furniture.id == kind and furniture.cframe == properties.cframe then
            return true
        end
    end
    return false
end

local function buyFurnitureWithRetry(id, props)
    local args = {
        {
            {
                properties = props,
                kind = id
            }
        }
    }
    router.get("HousingAPI/BuyFurnitures"):InvokeServer(unpack(args))
    task.wait(0.1)
    if not furnitureExists(id, props) then
        warn("Couldn't buy furniture, retrying")
        buyFurnitureWithRetry(id, props)
    end
end	

local function getFurnitures()
    local furnitureIds = {
        "toilet",
        "modernshower",
        "ailments_refresh_2024_cheap_food_bowl",
        "ailments_refresh_2024_cheap_water_bowl",
        "cheapbathtub",
        "basiccrib",
		"lures_2023_normal_lure",
    }
    
    local furnitureToId = {}
    local houseFurniture = cd.get("house_interior").furniture
    
    for _, furnitureId in ipairs(furnitureIds) do
        local found = false
        for furnitureDbId, furnitureData in pairs(houseFurniture) do
            if furnitureData.id == furnitureId then
                furnitureToId[furnitureId] = furnitureDbId
                found = true
                break
            end
        end
        
        if not found then
            buyFurnitureWithRetry(furnitureId, {cframe = CFrame.new(0, 0, 0)})
            task.wait(0.1)
            houseFurniture = cd.get("house_interior").furniture -- Refresh after buying
            for furnitureDbId, furnitureData in pairs(houseFurniture) do
                if furnitureData.id == furnitureId then
                    furnitureToId[furnitureId] = furnitureDbId
                    break
                end
            end
        end
    end
    
    return furnitureToId
end
local function get_items_of_kind(kind, category)
	local items = {}
	for i,v in cd.get("inventory")[category] do
		if v.id == kind then
			table.insert(items, v)
		end
	end
	return items
end
local function getBoneId()
    for toyId, toyData in pairs(cd.get("inventory").toys) do
        if toyData.kind == "squeaky_bone_default" then
            return toyId
        end
    end
end

local function useBone()
    local args = {
        "__Enum_PetObjectCreatorType_1",
        {
            reaction_name = "ThrowToyReaction",
            unique_id = getBoneId()
        }
    }
    router.get("PetObjectAPI/CreatePetObject"):InvokeServer(unpack(args))
end

local function setupTeleportHook()
    local soaux = loadstring(game:HttpGet("https://raw.githubusercontent.com/0Void2391/Sulfoxide/refs/heads/main/soaux.lua"))()
    local constants = {
        "settings",
        "touch_to_enter",
        "destination_id",
        "current_location",
        "player_about_to_be_unanchored"
    }
    
    local func = soaux.searchClosure(ReplicatedStorage.ClientModules.Core.InteriorsM.InteriorsM, 
                                    "unanchor_and_teleport_player_async", constants)
    
    local old
    old = hookfunction(func, function(var)
        if getgenv().teleport == false then
            return
        end
        return old(var)
    end)
end

local function loadInterior(interiorType, teleport, name)
    setthreadidentity(2)
    local interiors = Fsys.load("InteriorsM")
    local enter = interiors.enter
    
    getgenv().teleport = teleport
    
    if interiorType == "interior" then
		if not workspace.Interiors:GetChildren()[1] or not string.find(workspace.Interiors:GetChildren()[1].Name,name) then
			enter(name, "", {})
		end
    elseif interiorType == "house" then 
		if not workspace.HouseInteriors.blueprint:FindFirstChild(plr.Name) then
        	enter("housing", "MainDoor", {house_owner = name})
		end
    end
    
    setthreadidentity(8)
end

local function useFurniture(furniture, char)
    local furnitureToId = getFurnitures()
    local id = furnitureToId[furniture]
    local args = {
        plr,
        id,
        furniture == "toilet" and "Seat1" or "UseBlock",
        {
            cframe = plr.Character:WaitForChild("HumanoidRootPart").CFrame
        },
        char
    }
    router.get("HousingAPI/ActivateFurniture"):InvokeServer(unpack(args))
end

local function heal()
    repeat task.wait() until cd.get("house_interior").furniture ~= nil
    for furnitureId, furnitureData in pairs(cd.get("house_interior").furniture) do
        if furnitureData.id == "doctor" then
            local args = {
                furnitureId,
                "UseBlock",
                "Yes",
                plr.Character
            }
            router.get("HousingAPI/ActivateInteriorFurniture"):InvokeServer(unpack(args))
        end
    end
end

local function refillFood()
    loadInterior("interior", false, "PizzaShop")
    task.wait(0.2)
    for _ = 1, 20 do
        local args = {
            "f-12",
            "Ham",
            nil,
            plr.Character
        }
        router.get("HousingAPI/ActivateInteriorFurniture"):InvokeServer(unpack(args))
    end
end

local function eatFood()
    local ham
    local inventoryFood = cd.get("inventory").food
    for foodId, foodData in pairs(inventoryFood) do
        if foodData.kind == "pizza_shop_ham" then
            ham = foodId
            break
        end
    end
    
    if not ham then
        refillFood()
        inventoryFood = cd.get("inventory").food -- Refresh
        for foodId, foodData in pairs(inventoryFood) do
            if foodData.kind == "pizza_shop_ham" then
                ham = foodId
                break
            end
        end
    end
    
    router.get("ToolAPI/ServerUseTool"):FireServer(ham, "START")
    task.wait(0.5)
    router.get("ToolAPI/ServerUseTool"):FireServer(ham, "END")
    task.wait(0.5)
end

local function refillWater()
    loadInterior("interior", false, "PizzaShop")
    task.wait(0.2)
    for _ = 1, 20 do
        local args = {
            "f-90",
            "UseBlock",
            nil,
            plr.Character
        }
        router.get("HousingAPI/ActivateInteriorFurniture"):InvokeServer(unpack(args))
    end
end

local function drinkWater()
    local water
    local inventoryFood = cd.get("inventory").food
    for foodId, foodData in pairs(inventoryFood) do
        if foodData.kind == "water_paper_cup" then
            water = foodId
            break
        end
    end
    
    if not water then
        refillWater()
        inventoryFood = cd.get("inventory").food -- Refresh
        for foodId, foodData in pairs(inventoryFood) do
            if foodData.kind == "water_paper_cup" then
                water = foodId
                break
            end
        end
    end
    
    router.get("ToolAPI/ServerUseTool"):FireServer(water, "START")
    task.wait(0.5)
    router.get("ToolAPI/ServerUseTool"):FireServer(water, "END")
    task.wait(0.5)
end

local function solveMysteryEnhanced(pet)
    if not cd.get("ailments_manager") or not cd.get("ailments_manager").ailments or not cd.get("ailments_manager").ailments[pet] then 
        warn("[MYSTERY] No ailments found for pet: " .. tostring(pet))
        return nil 
    end

    local success, result = pcall(function()
        setthreadidentity(2)
        local WeightedRandom = require(ReplicatedStorage.new.modules.Utilities.WeightedRandom)
        local LegacyLoad = require(ReplicatedStorage.new.modules.LegacyLoad)
        local CloudValues = LegacyLoad("CloudValues")
        local MysteryHelper = require(ReplicatedStorage.new.modules.Ailments.Helpers.MysteryHelper)
        
        local mystery = cd.get("ailments_manager").ailments[pet].mystery
        if not mystery or not mystery.components then return nil end
        
        local components = MysteryHelper.get_action(mystery)
        if not components or not components.options then return nil end
        
        local seed = components.options.random_seed
        local get_ailment_slots = components.options.get_ailment_slots
        if not seed or not get_ailment_slots then return nil end
        
        local function get_slot_categories(v11)
            local zotti = CloudValues:getValue("ailments", "mysteryAilmentCategoryWeights")
            if not zotti then return nil end
            return WeightedRandom.get_values(zotti, 3, v11)
        end
        
        local petTable
        for _, v in pairs(getgc(true)) do
            if typeof(v) == "table" and rawget(v, "pet_id") and rawget(v, "player") == plr then
                petTable = v
                break
            end
        end
        if not petTable then return nil end
        
        local slots = get_slot_categories(seed)
        if not slots then return nil end
        
        return get_ailment_slots(seed, slots, petTable)
    end)
    
    setthreadidentity(8)
    
    if not success then
        warn("[MYSTERY] Error solving mystery: " .. tostring(result))
        return nil
    end
    
    return result
end

local function antiAFK()
    local GC = getconnections or get_signal_cons
    if GC then
        for _, connection in pairs(getconnections(plr.Idled)) do
            if connection["Disable"] then
                connection["Disable"](connection)
            elseif connection["Disconnect"] then
                connection["Disconnect"](connection)
            end
        end
    else
        local VirtualUser = cloneref(game:GetService("VirtualUser"))
        plr.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end
end


local startAutoFarm
-- Ailment Handling
local function waitForAilmentFinish(ailment, callback, ailmentType, pet)
    local started = tick()
    
    repeat 
        task.wait()
        if callback then callback() end
        
        local ailments = getAilments(ailmentType, pet)
        if not ailments[ailment] then
            break
        end
        
        if tick() - started >= 70 then
            print("[DEBUG] Task timed out, restarting autofarm.")
            task.spawn(startAutoFarm)
            coroutine.yield() -- Stop the current thread
        end
    until not getAilments(ailmentType, pet)[ailment]
end

-- OPTIMIZATION: Define large, static tables once to save memory.
local ORGAN_STEP_POSITIONS = {
    Vector3.new(-335.31, 33.05, -1448.59), Vector3.new(-338.49, 34.48, -1447.55),
    Vector3.new(-343.19, 36.64, -1446.23), Vector3.new(-345.65, 38.63, -1442.83),
    Vector3.new(-349.2, 40.55, -1439.78), Vector3.new(-350.44, 42.8, -1435.09),
    Vector3.new(-351.23, 44.26, -1431.61), Vector3.new(-350.76, 46.42, -1426.64),
    Vector3.new(-348.43, 48.89, -1421.59), Vector3.new(-345.55, 50.33, -1419.6),
    Vector3.new(-341.97, 52.25, -1417.48), Vector3.new(-337.78, 54.32, -1415.81),
    Vector3.new(-333.76, 56.16, -1414.92), Vector3.new(-328.45, 58.66, -1415.77),
    Vector3.new(-324.91, 60.22, -1417), Vector3.new(-321.42, 62.31, -1420.06),
    Vector3.new(-319.07, 64.12, -1423.32), Vector3.new(-318.95, 65.77, -1426.79),
    Vector3.new(-318.72, 68.21, -1431.8), Vector3.new(-318.53, 70.24, -1436.03),
    Vector3.new(-319.19, 71.85, -1439.38), Vector3.new(-321.86, 74.05, -1443.46),
    Vector3.new(-325.87, 76.42, -1446.56), Vector3.new(-329.74, 78.31, -1448.4),
    Vector3.new(-333.65, 80.09, -1449.11), Vector3.new(-337.63, 82.19, -1446.86),
    Vector3.new(-341.83, 84.57, -1444.76), Vector3.new(-345.98, 86.8, -1442.68), 
    Vector3.new(-350.2, 89.1, -1440.5)
}

local function scaleTheOrgan(pet, ailmentType)
    loadInterior("interior", false, "MainMap!Fall")
    task.wait(0.5)
    local character = plr.Character or plr.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")
    
    local oldPos = rootPart.CFrame
    resetPet(pet)
    task.wait(0.5)
    
    for _, position in ipairs(ORGAN_STEP_POSITIONS) do
        rootPart.CFrame = CFrame.new(position) + Vector3.new(0, 3, 0)
        task.wait(1.5)
    end
    task.wait(1) 
    
    waitForAilmentFinish("scale_the_organ", nil, ailmentType, pet)
    rootPart.CFrame = oldPos
end

-- OPTIMIZATION: Centralized function to teleport to a low-rendering area
local function teleportToLimbo()
    if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        plr.Character.HumanoidRootPart.CFrame = CFrame.new(100, 1002, 100)
    end
end

local ailmentFunctions = {
    ["scale_the_organ"] = function(pet, ailmentType) scaleTheOrgan(pet, ailmentType) end,
    ["toilet"] = function(pet)
        loadInterior("house", false, plr)
        resetPet(pet)
        task.wait(0.2)
        task.spawn(useFurniture, "toilet", getPetChar(pet))
        waitForAilmentFinish("toilet", nil, "pet", pet)
    end,
    ["hungry"] = function(pet)
        loadInterior("house", false, plr)
        resetPet(pet)
        task.wait(0.2)
        task.spawn(useFurniture, "ailments_refresh_2024_cheap_food_bowl", getPetChar(pet))
        waitForAilmentFinish("hungry", nil, "pet", pet)
    end,
    ["sick"] = function(pet, ailmentType)
        loadInterior("interior", false, "Hospital")
        task.wait(0.5)
        heal()
        waitForAilmentFinish("sick", nil, ailmentType, pet)
    end,
    ["thirsty"] = function(pet)
        loadInterior("house", false, plr)
        resetPet(pet)
        task.wait(0.2)
        task.spawn(useFurniture, "ailments_refresh_2024_cheap_water_bowl", getPetChar(pet))
        waitForAilmentFinish("thirsty", nil, "pet", pet)
    end,
    ["sleepy"] = function(pet)
        loadInterior("house", false, plr)
        resetPet(pet)
        task.wait(0.2)
        task.spawn(useFurniture, "basiccrib", getPetChar(pet))
        waitForAilmentFinish("sleepy", nil, "pet", pet)
    end,
    ["camping"] = function(pet, ailmentType)
        loadInterior("interior", false, "MainMap")
		local oldPos = plr.Character:WaitForChild("HumanoidRootPart").CFrame
		local targetPos = workspace.StaticMap.Campsite.CampsiteOrigin.Position + Vector3.new(0, 3, 0)
		plr.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos)
        task.wait(0.2)
        resetPet(pet)
        waitForAilmentFinish("camping", nil, ailmentType, pet)
        plr.Character.HumanoidRootPart.CFrame = oldPos
    end,
    ["bored"] = function(pet, ailmentType)
        loadInterior("interior", false, "MainMap")
		local oldPos = plr.Character:WaitForChild("HumanoidRootPart").CFrame
        local targetPos = workspace.StaticMap.Park.BoredAilmentTarget.Position + Vector3.new(0, 2, 0)
		plr.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos)
        task.wait(0.2)
        resetPet(pet)
        waitForAilmentFinish("bored", nil, ailmentType, pet)
        plr.Character.HumanoidRootPart.CFrame = oldPos
    end,
    ["salon"] = function(pet, ailmentType)
        loadInterior("interior", false, "Salon")
        waitForAilmentFinish("salon", nil, ailmentType, pet)
    end,
    ["play"] = function(pet)
        resetPet(pet)
        waitForAilmentFinish("play", function() 
            useBone()
            task.wait(10.5) 
        end, "pet", pet)
    end,
    ["beach_party"] = function(pet, ailmentType)
        loadInterior("interior", false, "MainMap")
		local oldPos = plr.Character:WaitForChild("HumanoidRootPart").CFrame
        local targetPos = workspace.Interiors:FindFirstChildWhichIsA("Model").Buildings.BeachShop.Visual.BeachShopSetDressing:GetPivot().Position
		plr.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos)
        task.wait(0.2)
        resetPet(pet)
        waitForAilmentFinish("beach_party", nil, ailmentType, pet)
        plr.Character.HumanoidRootPart.CFrame = oldPos
    end,
    ["ride"] = function(pet)
        teleportToLimbo()
        resetPet(pet)
        useStroller(pet)
        waitForAilmentFinish("ride", randomMove, "pet", pet)
        teleportToLimbo()
        unequipStroller(pet)
    end,
    ["dirty"] = function(pet)
        loadInterior("house", false, plr)
        task.spawn(useFurniture, "modernshower", getPetChar(pet))
        waitForAilmentFinish("dirty", nil, "pet", pet)
        resetPet(pet)
    end,
    ["walk"] = function(pet)
		router.get("AdoptAPI/HoldBaby"):FireServer(getPetChar(pet))
        waitForAilmentFinish("walk", randomMove, "pet", pet)
		router.get("AdoptAPI/EjectBaby"):FireServer(getPetChar(pet))
		teleportToLimbo()
    end,
    ["pet_me"] = function(pet)
        teleportToLimbo()
        resetPet(pet)
        task.wait(0.5)
        local petChar = getPetChar(pet)
        local function complete()
            if petChar and petChar:FindFirstChild("HumanoidRootPart") then
                local camera = workspace.CurrentCamera
                local petPos = petChar.HumanoidRootPart.Position
                local viewportPoint = camera:WorldToViewportPoint(petPos)
                pcall(function()
                    local vim = game:GetService("VirtualInputManager")
                    vim:SendMouseButtonEvent(viewportPoint.X, viewportPoint.Y, 0, true, game, 1)
                    task.wait(0.05)
                    vim:SendMouseButtonEvent(viewportPoint.X, viewportPoint.Y, 0, false, game, 1)
                end)
                task.wait(0.3)
                router.get("AilmentsAPI/ProgressPetMeAilment"):FireServer(pet)
            end
        end
        waitForAilmentFinish("pet_me", complete, "pet", pet)
        task.wait(0.3)
        pcall(function()
            local backButton = plr.PlayerGui.FocusPetApp.Frame.BackButton
            if backButton then
                firesignal(backButton.MouseButton1Down)
                firesignal(backButton.MouseButton1Up)
                firesignal(backButton.MouseButton1Click)
            end
        end)
    end,
    ["school"] = function(pet, ailmentType)
        loadInterior("interior", false, "School")
        waitForAilmentFinish("school", nil, ailmentType, pet)
    end,
    ["mystery"] = function(pet)
        local solved = solveMysteryEnhanced(pet)
        if not solved then
            warn("[MYSTERY] Enhanced solver failed, skipping mystery ailment")
            return
        end
        
        for choice = 1, 3 do
            if solved[choice] then
                if pcall(router.get("AilmentsAPI/ChooseMysteryAilment").FireServer, router.get("AilmentsAPI/ChooseMysteryAilment"), pet, "mystery", choice, solved[choice]) then
                    break 
                end
            end
        end
        
        waitForAilmentFinish("mystery", nil, "pet", pet)
        solved = nil -- OPTIMIZATION: Clear memory after use
    end,
    ["pizza_party"] = function(pet, ailmentType)
        loadInterior("interior", false, "PizzaShop")
        waitForAilmentFinish("pizza_party", nil, ailmentType, pet)
    end
}

local babyAilmentsFunctions = {
    ["scale_the_organ"] = function() scaleTheOrgan(nil, "baby") end,
    ["hungry"] = function()
        waitForAilmentFinish("hungry", eatFood, "baby")
    end,
    ["thirsty"] = function()
        waitForAilmentFinish("thirsty", drinkWater, "baby")
    end,
    ["sleepy"] = function()
        loadInterior("house", false, plr)
        task.spawn(useFurniture, "basiccrib", plr.Character)
        waitForAilmentFinish("sleepy", nil, "baby")
        router.get("PetAPI/ExitFurnitureUseStates"):InvokeServer()
        router.get("AdoptAPI/ExitSeatStates"):FireServer()
    end,
    ["dirty"] = function()
        loadInterior("house", false, plr)
        task.spawn(useFurniture, "modernshower", plr.Character)
        waitForAilmentFinish("dirty", nil, "baby")
        router.get("PetAPI/ExitFurnitureUseStates"):InvokeServer()
        router.get("AdoptAPI/ExitSeatStates"):FireServer()
    end
}

local function handlelures()
	loadInterior("house", false, plr)
	getFurnitures()
	local bait = get_items_of_kind("ice_dimension_2025_shiver_cone_bait", "food")[1] or get_items_of_kind("ice_dimension_2025_ice_soup_bait", "food")[1]
	local lure = cd.get("house_interior").furniture[getFurnitures()["lures_2023_normal_lure"]]
	if lure.lure and lure.lure.finished and lure.lure.reward then
		router.get("HousingAPI/ActivateFurniture"):InvokeServer(plr, getFurnitures()["lures_2023_normal_lure"], "UseBlock", {bait_unique = nil}, plr.Character)
	end
	if not lure.lure then 
		router.get("HousingAPI/ActivateFurniture"):InvokeServer(plr, getFurnitures()["lures_2023_normal_lure"], "UseBlock", {bait_unique = bait.unique}, plr.Character)
	end
end
local function questhandler()
	local quests = cd.get("quest_manager").quests_cached
	for i,v in pairs(quests) do
		if v.steps_completed >= 1 then
			router.get("QuestAPI/ClaimQuest"):InvokeServer(i)
		end
	end
end
-- Main AutoFarm Function
startAutoFarm = function()
    teleportToLimbo()
    task.wait(0.4)
    
    local currentPetId = getPetId()
    resetPet(currentPetId)
    
    for i = 1, 17 do
		if not cd.get("daily_login_manager").claimed_star_rewards["reward_"..i] then
			router.get("DailyLoginAPI/ClaimStarReward"):InvokeServer("reward_"..i)
			break
		end
	end
	router.get("DailyLoginAPI/ClaimDailyReward"):InvokeServer()
    
    while true do -- Changed from task.wait() for explicit delay at the end
        local inventoryPets = cd.get("inventory").pets
        local petExists = inventoryPets[currentPetId]
        local currentPetData = petExists and inventoryPets[currentPetId]
        
        local shouldSwitchPet = false
        if not petExists then
            shouldSwitchPet = true
        elseif currentPetData and currentPetData.properties then
            if currentPetData.properties.age == 6 and getgenv().farmsettings.switchpetsongrown then
                shouldSwitchPet = true
            end
            local petInfo = inventorydb.pets[currentPetData.kind]
            if petInfo and not petInfo.is_egg and getgenv().farmsettings.prioritizeeggs then
                shouldSwitchPet = true
            end
            
            if not getgenv().farmsettings.prioritizeeggs and currentPetData.properties.age then
                local currentAge = currentPetData.properties.age
                local highestAge = currentAge
                for _, petData in pairs(inventoryPets) do
                    if petData.properties and petData.properties.age and petData.id ~= "practice_dog" and petData.properties.age > highestAge then
                        highestAge = petData.properties.age
                    end
                end
                if highestAge > currentAge then
                    shouldSwitchPet = true
                end
            end
        end
        
        if shouldSwitchPet then
            local newPetId = getPetId()
            if newPetId and newPetId ~= currentPetId then
                resetPet(newPetId)
                currentPetId = newPetId
            elseif not newPetId then
                router.get("ToolAPI/Equip"):InvokeServer(currentPetId)
            end
        else
            router.get("ToolAPI/Equip"):InvokeServer(currentPetId)
        end
        
        setthreadidentity(8)
        local petName = getPetNameFromId(currentPetId)
        if gui.Frame.Title.Pet.Text ~= "Current pet: " .. petName then
            gui.Frame.Title.Pet.Text = "Current pet: " .. petName
        end

        questhandler()
        
        setthreadidentity(8)
        gui.Frame.Title.Task.Text = "Current task: None"
        for ailment, _ in pairs(getAilments("pet", currentPetId)) do
            task.wait(0.1)
            setthreadidentity(8)
            gui.Frame.Title.Task.Text = "Current task: " .. ailment
            ailmentFunctions[ailment](currentPetId, "pet")
            setthreadidentity(8)
            gui.Frame.Title.Task.Text = "Current task: None"
        end
        
        if getgenv().farmsettings.babyfarm then
            for ailment, _ in pairs(getAilments("baby")) do
                task.wait(0.1)
                setthreadidentity(8)
                gui.Frame.Title.Task.Text = "Current task: baby " .. ailment
                if not getAilments(currentPetId)[ailment] and not babyAilmentsFunctions[ailment] then
                    ailmentFunctions[ailment](nil, "baby")
                elseif babyAilmentsFunctions[ailment] then
                    babyAilmentsFunctions[ailment]()
                end
                setthreadidentity(8)
                gui.Frame.Title.Task.Text = "Current task: None"
            end
        end
        handlelures()
        
        task.wait(0.5) -- OPTIMIZATION: Reduce CPU usage by not polling constantly.
    end
end
-- GUI Update Functions
local function getPotions()
    local count = 0
    for _, foodData in pairs(cd.get("inventory").food) do
        if foodData.id == "pet_age_potion" then
            count = count + 1
        end
    end
    setthreadidentity(8)
    return count
end

local function updateGUI()
    local startTime = tick()
    local startPotions = getPotions()
    local playerData = cd.get_data()[plr.Name]
    local startMoney = playerData.money
    
    -- OPTIMIZATION: Store old values to prevent updating text if it hasn't changed.
    local oldTime, oldMoney, oldPotions
  
    while task.wait(3) do
        setthreadidentity(8)
        
        local newTime = "Time elapsed: " .. formatTime(tick() - startTime)
        if newTime ~= oldTime then
            gui.Frame.Title.Time.Text = newTime
            oldTime = newTime
        end
        
        local newMoney = "Money farmed: " .. (playerData.money - startMoney)
        if newMoney ~= oldMoney then
            gui.Frame.Title.Money.Text = newMoney
            oldMoney = newMoney
        end

        local currentPotions = getPotions()
        local newPotions = "Gained potions: " .. (currentPotions - startPotions)
        if newPotions ~= oldPotions then
            gui.Frame.Title.Potions.Text = newPotions
            oldPotions = newPotions
        end
		
		gui.Frame.Visible = getgenv().farmsettings.gui
    end
end

local function init()
	if getgenv().farmsettings.babyfarm then
		local TeamAPIChooseTeam = router.get("TeamAPI/ChooseTeam") 
		TeamAPIChooseTeam:InvokeServer("Babies", {dont_respawn = true, source_for_logging = "avatar_editor"})
	end
    setupTeleportHook()
    local baseplate = Instance.new("Part")
    baseplate.Size = Vector3.new(100,2,100)
    baseplate.CFrame = CFrame.new(100,1000,100)
    baseplate.Parent = workspace
    baseplate.Anchored = true
    baseplate.Archivable = false
    
    getgenv().running = true
    antiAFK()
    task.spawn(updateGUI)
    task.spawn(autoClaimTreatBag)
    task.spawn(autoJoinPoller)

	if not (#get_items_of_kind("trade_license", "toys") > 0) then
		loadInterior("interior", true, "SafetyHub")
		router.get("SettingsAPI/SetBooleanFlag"):FireServer("has_talked_to_trade_quest_npc", true)
		loadInterior("interior", true, "TradeLicenseZone")
		router.get("TradeAPI/BeginQuiz"):FireServer()
		repeat task.wait() until cd.get("trade_license_quiz_manager")
		for i = 1,3 do
			router.get("TradeAPI/AnswerQuizQuestion"):FireServer(cd.get("trade_license_quiz_manager").quiz[i].answer)
		end
	end
    startAutoFarm()
end
task.wait(7)
init()
