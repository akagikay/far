--[[
    CONSOLIDATED ADOPT ME MANAGER SCRIPT
    - Protocol: Executor HTTP Request
    - Optimization: Data Cleaning + CHUNKING (Fixes Timeouts)
]]

--================================================================================
-- CONFIGURATION
--================================================================================

local USER_CREDENTIALS = {
    username = "akagikay",
    password = "12345t"
}

local PING_INTERVAL = 120
local INVENTORY_INTERVAL = 43200
local INITIAL_WAIT = 60

-- CHUNKING CONFIG (Safe size for Executors)
local CHUNK_SIZE = 500 * 1024 -- 500 KB

local URLS = {
    RECEPTOR = "https://raw.githubusercontent.com/akagikay/adoptmemanager/refs/heads/main/receptor_url.txt",
    KEEPALIVE = "https://raw.githubusercontent.com/akagikay/adoptmemanager/refs/heads/main/keepalive_url.txt"
}

local TARGET_MODULE_PATH = "ClientStore"
local BASE_SERVICE_PATH = game:GetService("ReplicatedStorage"):WaitForChild("ClientModules"):WaitForChild("Core")

--================================================================================
-- HTTP & UTILITIES
--================================================================================

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()

local http_request = (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or request

if not http_request then
    warn("CRITICAL: This script requires an executor with a custom request() function.")
    return
end

local function fetch_dynamic_url(github_url)
    local success, response = pcall(function()
        return game:HttpGet(github_url)
    end)
    if success and response then
        return response:gsub("^%s*(.-)%s*$", "%1")
    end
    return nil
end

--================================================================================
-- CHUNKING LOGIC
--================================================================================

local function chunk_and_send(serverUrl, dataTable)
    -- 1. Encode the full data to JSON first
    local success, jsonString = pcall(function()
        return HttpService:JSONEncode(dataTable)
    end)

    if not success then
        return warn("[Chunking] JSON Encode failed. Data might be recursive or invalid.")
    end

    local totalLen = #jsonString
    local transferId = HttpService:GenerateGUID(false)
    local chunkCount = math.ceil(totalLen / CHUNK_SIZE)

    print(string.format("[Chunking] Payload size: %.2f MB. Splitting into %d chunks.", totalLen / 1024 / 1024, chunkCount))

    for i = 1, chunkCount do
        -- Calculate substring indices
        local startIdx = ((i - 1) * CHUNK_SIZE) + 1
        local endIdx = math.min(i * CHUNK_SIZE, totalLen)

        local chunkData = string.sub(jsonString, startIdx, endIdx)

        -- Create the metadata payload
        local payload = {
            transfer_id = transferId,
            chunk_index = i - 1, -- Python uses 0-based indexing usually, but logic handles it
            total_chunks = chunkCount,
            data = chunkData
        }

        local chunkJson = HttpService:JSONEncode(payload)

        -- Send Chunk
        local response = http_request({
            Url = serverUrl .. "/receive-data",
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = chunkJson
        })

        if not response or (response.StatusCode ~= 200 and response.Status ~= 200) then
            warn("[Chunking] Failed to send chunk " .. i .. ". Aborting transfer.")
            return false
        end

        -- Small wait to prevent client freezing between HTTP calls
        task.wait(0.1)
    end

    print("[Chunking] Transfer complete.")
    return true
end

--================================================================================
-- DATA EXTRACTION & CLEANING
--================================================================================

local function clean_inventory(rawData)
    if type(rawData) ~= "table" then return rawData end
    local cleaned = {}

    for category, items in pairs(rawData) do
        if type(items) == "table" then
            cleaned[category] = {}
            for uid, itemData in pairs(items) do
                if type(itemData) == "table" then
                    local newItem = {}
                    newItem.id = itemData.id
                    newItem.oid = itemData.oid
                    newItem.count = itemData.count

                    if itemData.properties then
                        newItem.age = itemData.properties.age
                        newItem.rideable = itemData.properties.rideable
                        newItem.flyable = itemData.properties.flyable
                    else
                        newItem.age = itemData.age
                        newItem.rideable = itemData.rideable
                        newItem.flyable = itemData.flyable
                    end

                    cleaned[category][uid] = newItem
                else
                    cleaned[category][uid] = itemData
                end
            end
        else
            cleaned[category] = items
        end
    end
    return cleaned
end

local function getModuleFromPath(base, path)
    local current = base
    for segment in path:gmatch("[^.]+") do
        if not current then return nil end
        current = current:FindFirstChild(segment)
    end
    return current
end

local function extractInventory(data)
    if type(data) == "table" and data.store and data.store._state and data.store._state.inventory then
        return data.store._state.inventory
    end
    return nil
end

local function getBucksValue()
    local success, result = pcall(function()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui", 20)
        local bucksApp = playerGui:WaitForChild("BucksIndicatorApp", 20)
        local indicator = bucksApp:WaitForChild("CurrencyIndicator", 20)
        local container = indicator:WaitForChild("Container", 20)
        local label = container:WaitForChild("Amount", 20)
        local cleanText = string.gsub(label.Text, "[^%d%.]", "")
        return tonumber(cleanText)
    end)
    if success and result then return result end
    return nil
end

--================================================================================
-- SENDING FUNCTIONS
--================================================================================

local function sendInventory()
    print("[Inventory] Collecting data...")

    local serverUrl = fetch_dynamic_url(URLS.RECEPTOR)
    if not serverUrl then return warn("[Inventory] Could not fetch Server URL") end

    local moduleScript = getModuleFromPath(BASE_SERVICE_PATH, TARGET_MODULE_PATH)
    if not moduleScript then return warn("[Inventory] ClientStore not found") end

    local success, result = pcall(require, moduleScript)
    if not success then return warn("[Inventory] Failed to require ClientStore") end

    local rawInv = extractInventory(result)
    if not rawInv then return warn("[Inventory] Inventory table is nil") end

    -- Clean the data first to reduce size
    local cleanedInv = clean_inventory(rawInv)
    cleanedInv.bucks = getBucksValue()

    -- Final Object
    local dataObj = {
        creds = string.format("%s:%s:%s", USER_CREDENTIALS.username, USER_CREDENTIALS.password, LocalPlayer.Name),
        inv = cleanedInv
    }

    -- Send using the new Chunking System
    chunk_and_send(serverUrl, dataObj)
end

local function sendPing()
    local tunnelUrl = fetch_dynamic_url(URLS.KEEPALIVE)
    if not tunnelUrl then return end

    local payload = {
        user = USER_CREDENTIALS.username,
        password = USER_CREDENTIALS.password,
        roblox_username = LocalPlayer.Name
    }

    http_request({
        Url = tunnelUrl .. "/ping",
        Method = "POST",
        Headers = { ["Content-Type"] = "application/json" },
        Body = HttpService:JSONEncode(payload)
    })
end

--================================================================================
-- THREAD EXECUTION
--================================================================================

if not game:IsLoaded() then game.Loaded:Wait() end

-- Ping Loop
task.spawn(function()
    while true do
        sendPing()
        task.wait(PING_INTERVAL)
    end
end)

-- Inventory Loop
task.spawn(function()
    print("Inventory Thread Started - Waiting " .. INITIAL_WAIT .. "s for GUI load...")
    task.wait(INITIAL_WAIT)
    while true do
        sendInventory()
        print("Inventory sent (Chunked). Sleeping for 12 hours...")
        task.wait(INVENTORY_INTERVAL)
    end
end)
