wait(0.1)
repeat task.wait() until game:IsLoaded()
task.wait(2.5)
setthreadidentity(2)
-- Services and modules
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local GuiService = game:GetService("GuiService")
local plr = Players.LocalPlayer
local router = require(ReplicatedStorage.ClientModules.Core.RouterClient.RouterClient)
local cd = require(ReplicatedStorage.ClientModules.Core.ClientData)
local petentitymanager = require(ReplicatedStorage.ClientModules.Game.PetEntities.PetEntityManager)
local inventorydb = require(ReplicatedStorage.ClientDB.Inventory.InventoryDB)
local minigamemanager = require(game:GetService("ReplicatedStorage").ClientModules.Game.MinigameClientManager)
local terrainhelper = require(game:GetService("ReplicatedStorage").SharedModules.TerrainHelper)
local Fsys = require(ReplicatedStorage.Fsys)
local liveopstime = Fsys.load("LiveOpsTime")
setthreadidentity(8)
if plr.Character == nil then
	router.get("LegacyTutorialAPI/MarkTutorialCompleted"):FireServer()
	router.get("LegacyTutorialAPI/EquipTutorialEgg"):FireServer()
    repeat 
        local playbutton = game:GetService("Players").LocalPlayer.PlayerGui.NewsApp.EnclosingFrame.MainFrame.Buttons.PlayButton
        firesignal(playbutton.MouseButton1Down)
        firesignal(playbutton.MouseButton1Up)
        firesignal(playbutton.MouseButton1Click)
        task.wait(1)
		if game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Visible then
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Info.Response:GetChildren()[8].MouseButton1Down)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Info.Response:GetChildren()[8].MouseButton1Up)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Info.Response:GetChildren()[8].MouseButton1Click)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Buttons.ButtonTemplate.MouseButton1Down)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Buttons.ButtonTemplate.MouseButton1Up)
            firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.ThemeColorDialog.Buttons.ButtonTemplate.MouseButton1Click)
        else
			firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.SpawnChooserDialog.UpperCardContainer.ChoicesContent.Choices.Home.Button.MouseButton1Down)
			firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.SpawnChooserDialog.UpperCardContainer.ChoicesContent.Choices.Home.Button.MouseButton1Up)
			firesignal(game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.SpawnChooserDialog.UpperCardContainer.ChoicesContent.Choices.Home.Button.MouseButton1Click)
		end
    until not (plr.Character == nil)
end
-- Fires the remote to make the pop-up appear
local args = {
    "ruin_rush"
}
local success, result = pcall(function()
    local API = game:GetService("ReplicatedStorage"):WaitForChild("API", 10)
    if API then
        local LobbyCreate = API:WaitForChild("MinigameAPI/LobbyCreate", 10)
        if LobbyCreate then
            return LobbyCreate:InvokeServer(unpack(args))
        end
    end
end)

if not success then
    warn("Failed to invoke LobbyCreate: " .. tostring(result))
end

task.wait(0.5)

-- Functions to find and click UI buttons by their text
function findUiElementByText(text)
    local placesToSearch = { game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"), game:GetService("CoreGui") }
    for _, container in pairs(placesToSearch) do
        for _, descendant in pairs(container:GetDescendants()) do
            if descendant:IsA("GuiObject") and pcall(function() return descendant.Text end) and descendant.Text == text then
                return descendant
            end
        end
    end
    return nil
end

function findClickableParent(startObject)
    local currentObject = startObject
    for i = 1, 10 do
        if currentObject:IsA("TextButton") or currentObject:IsA("ImageButton") then
            return currentObject
        end
        if currentObject.Parent then
            currentObject = currentObject.Parent
        else
            return nil
        end
    end
    return nil
end

local textLabel = findUiElementByText("Play Temple Trek")
if textLabel then
    local playButton = findClickableParent(textLabel)
    if playButton then
        warn("Clicking the Play button...")
        firesignal(playButton.MouseButton1Down); task.wait(0.05)
        firesignal(playButton.MouseButton1Up); task.wait(0.05)
        firesignal(playButton.MouseButton1Click)
    else
        warn("Could not find a clickable parent for the 'Play' button text.")
    end
else
    warn("Could not find the 'Play Temple Trek' text label.")
end

warn("Waiting for minigame to load...")
task.wait(7)

-- =================================================================== --
--                      PART 2: COLLECT THE SKULLS
-- =================================================================== --

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

-- Add error handling for API access
local API = ReplicatedStorage:FindFirstChild("API")
if not API then
    warn("API not found in ReplicatedStorage")
    return
end

local MessageServer = API:FindFirstChild("MinigameAPI/MessageServer")
if not MessageServer then
    warn("MessageServer not found in API")
    return
end

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local processedSkulls = {}
local instanceId = nil
local skullsCollected = 0

print("--- Smart GoldenSkull Hunter Activated (Low-FPS Enhanced) ---")
print("Monitoring Workspace.Interiors for new GoldenSkulls...")

function findAndCacheInstanceId()
    if instanceId then return instanceId end
    local Interiors = Workspace:FindFirstChild("Interiors")
    if Interiors then
        for _, child in pairs(Interiors:GetChildren()) do
            if child.Name:match("^RuinRushInterior::") then
                instanceId = child.Name:match("^RuinRushInterior::(.+)")
                return instanceId
            end
        end
    end
    return nil
end

function collectSkull(skullModel)
    if not findAndCacheInstanceId() then return end

    local fullPath = skullModel:GetFullName()
    local skullId = nil
    
    if fullPath:find("AztecEndRoom") then skullId = 1
    elseif fullPath:find("UpliftStones") then skullId = 2
    elseif fullPath:find("middle_room_") then skullId = 3 end
    
    if not skullId then return end
    
    print("\n--- Processing Found Skull #" .. skullId .. " ---")
    
    -- [[ REASONABLE AGGRESSIVE COLLECTION STRATEGY ]] --
    print("  -> PHASE 1: Pre-teleport collection attempts...")
    -- PRE-TELEPORT SPAM (reduced)
    for attempt = 1, 10 do
        pcall(function()
            local args = { "RuinRushInterior::" .. instanceId, "pickup_skull", skullId }
            MessageServer:FireServer(unpack(args))
        end)
        task.wait(0.03)
    end
    
    -- Continuous collection during teleport (reduced)
    local continuousCollection = coroutine.create(function()
        for attempt = 1, 50 do
            pcall(function()
                local args = { "RuinRushInterior::" .. instanceId, "pickup_skull", skullId }
                MessageServer:FireServer(unpack(args))
            end)
            task.wait(0.02) -- Every 20ms for 1 second total
        end
    end)
    
    print("  -> PHASE 2: Starting collection during teleport...")
    coroutine.resume(continuousCollection)
    
    -- Calculate target position
    local targetPosition
    if skullId == 3 and skullModel:FindFirstAncestor("AztecEndRoom") then
        local boulder = skullModel:FindFirstAncestor("RuinRushInterior"):FindFirstChild("Boulder", true)
        if boulder and boulder:IsA("Model") then
            targetPosition = boulder:GetPivot().Position + Vector3.new(0, 5, 0)
        else
            targetPosition = skullModel:GetPivot().Position + Vector3.new(0, 3, 0)
        end
    else
        targetPosition = skullModel:GetPivot().Position + Vector3.new(0, 3, 0)
    end
    
    -- Multiple teleports (reduced)
    print("  -> PHASE 3: Multiple teleports with collection...")
    for i = 1, 3 do
        humanoidRootPart.CFrame = CFrame.new(targetPosition)
        task.wait(0.1)
        -- Collection during each teleport
        for j = 1, 5 do
            pcall(function()
                local args = { "RuinRushInterior::" .. instanceId, "pickup_skull", skullId }
                MessageServer:FireServer(unpack(args))
            end)
        end
    end
    
    print("  -> PHASE 4: Extended post-teleport collection...")
    -- Extended post-teleport collection (reduced)
    for attempt = 1, 15 do
        pcall(function()
            local args = { "RuinRushInterior::" .. instanceId, "pickup_skull", skullId }
            MessageServer:FireServer(unpack(args))
        end)
        task.wait(0.05)
    end
    
    -- Try different positions (reduced)
    print("  -> PHASE 5: Testing alternate positions...")
    local positions = {
        targetPosition + Vector3.new(2, 0, 0),
        targetPosition + Vector3.new(-2, 0, 0),
        targetPosition + Vector3.new(0, 2, 0),
    }
    
    for _, pos in ipairs(positions) do
        humanoidRootPart.CFrame = CFrame.new(pos)
        task.wait(0.1)
        -- Collection at each position (reduced)
        for attempt = 1, 5 do
            pcall(function()
                local args = { "RuinRushInterior::" .. instanceId, "pickup_skull", skullId }
                MessageServer:FireServer(unpack(args))
            end)
            task.wait(0.03)
        end
    end
    
    print("  -> PHASE 6: Final collection burst...")
    -- Final collection burst (reduced)
    for attempt = 1, 20 do
        pcall(function()
            local args = { "RuinRushInterior::" .. instanceId, "pickup_skull", skullId }
            MessageServer:FireServer(unpack(args))
        end)
        if attempt % 10 == 0 then
            -- Re-teleport every 10 attempts
            humanoidRootPart.CFrame = CFrame.new(targetPosition)
        end
        task.wait(0.04)
    end
    
    print("  -> Collection complete for skull #" .. skullId)
    skullsCollected = skullsCollected + 1
    -- [[ END REASONABLE AGGRESSIVE COLLECTION ]]
end

-- [[ ENHANCED MONITORING: Longer timeout and more frequent checks ]] --
local startTime = tick()
local timeout = 180 -- Increased to 3 minutes for low FPS systems

while skullsCollected < 3 and (tick() - startTime) < timeout do
    task.wait(1) -- Reduced wait time for more frequent checks
    local interiors = Workspace:FindFirstChild("Interiors")
    if interiors then
        for _, model in pairs(interiors:GetDescendants()) do
            if model.Name == "GoldenSkull" and model:IsA("Model") then
                if not table.find(processedSkulls, model) then
                    print("!!! New GoldenSkull Detected !!! Path: " .. model:GetFullName())
                    table.insert(processedSkulls, model)
                    collectSkull(model)
                    
                    -- Extra wait after each skull collection for low FPS systems
                    print("  -> Extra stabilization wait...")
                    task.wait(2)
                end
            end
        end
    end
end
-- [[ END ENHANCED MONITORING ]]

-- =================================================================== --
--                      PART 3: EXIT THE MINIGAME
-- =================================================================== --
if skullsCollected < 3 then
    warn("Warning: Timed out or failed to collect all 3 skulls. Collected " .. skullsCollected .. "/3. Proceeding to exit...")
else
    print("\n=== All 3 Skulls Collected! ===")
end

print("Waiting 5 seconds before exiting (extended for low FPS)...")
task.wait(5)

-- Step 1: Click the first 'Exit Minigame' button
local playerGui = player:WaitForChild("PlayerGui", 10) -- Increased timeout
local minigameApp = playerGui and playerGui:WaitForChild("MinigameInGameApp", 10)
local exitButton = minigameApp and minigameApp:WaitForChild("ExitButton", 10)

if exitButton then
    warn("Found first Exit button! Clicking...")
    -- Multiple clicks for low FPS reliability
    for i = 1, 3 do
        firesignal(exitButton.MouseButton1Down); task.wait(0.1)
        firesignal(exitButton.MouseButton1Up); task.wait(0.1)
        firesignal(exitButton.MouseButton1Click); task.wait(0.1)
    end

    print("Waiting for the exit confirmation countdown (5 seconds for low FPS)...")
    task.wait(5)

    print("Searching for the final 'Exit Game' button...")
    local confirmExitText = findUiElementByText("Exit Game")
    if confirmExitText then
        local confirmExitButton = findClickableParent(confirmExitText)
        if confirmExitButton then
            warn("Found final Exit button! Clicking to confirm...")
            -- Multiple confirmation clicks for low FPS reliability
            for i = 1, 3 do
                firesignal(confirmExitButton.MouseButton1Down); task.wait(0.1)
                firesignal(confirmExitButton.MouseButton1Up); task.wait(0.1)
                firesignal(confirmExitButton.MouseButton1Click); task.wait(0.1)
            end
            warn("Multiple confirmation clicks sent.")
        end
    end
else
    warn("Could not find the first 'Exit Minigame' button at the expected path.")
end

print("--- Enhanced Low-FPS Script Finished ---")
wait(10)
script_key="TEldwxNsQHqqpHxBLteSOJUExppoESKz";
getgenv().Config = {
    ["PetFarmAutoSwitchFullGrown"] = false,
    ["PetFarmActive"] = true,
    ["EggFarmActive"] = false,
    ["HideUselessGui"] = true,
    ["Blur_username"] = true,
    ["Blazing_Lion_Log"] = false,
    ["DiscordId"] = "123456",
    ["Webhook"] = "",
}
loadstring(game:HttpGet("https://api.luarmor.net/files/v4/loaders/66567bfd337b57eb059b58dbe1badb89.lua"))()
